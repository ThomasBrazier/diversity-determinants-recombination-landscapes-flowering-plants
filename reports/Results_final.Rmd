---
title: "Recombination Landscapes in Angiosperms - Final results"
date: "`r Sys.Date()`"
csl: elsevier-harvard2.csl
output:
  # bookdown::pdf_document2: null
  bookdown::html_document2:
    keep_md: true
    toc: yes
  # pdf_document: default
  # bookdown::pdf_document2:
  #   toc: yes
  # bookdown::word_document2: default
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_dir = "output", output_format = "all") })
bibliography: bibliography.bib
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE, include = FALSE}
require(knitr)
library(bookdown)
knitr::opts_chunk$set(echo = TRUE)
# Set so that long lines in R will be wrapped:
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),tidy=TRUE)
```


# Dataset


```{r message = FALSE, warning = FALSE, include = FALSE}
# Loading libraries and scripts
packages = c("rstudioapi","ade4","ggplot2","MareyMap","stringr","gdata","taxize","taxizedb","dplyr","rentrez","rBLAST","Biostrings","purrr","ggpubr","reshape2","RColorBrewer","ggplotify","pals","cowplot","lme4","sjPlot","sjmisc","phyr","kableExtra","car","ape","plyr","lmerTest", "reldist", "pbmcapply", "MuMIn", "ggtree", "treeio", "ggnewscale", "dplyr", "data.table", "xlsx", "gridExtra", "magick", "ggtext", "ggrepel", "egg")
# lapply(packages, function(x) install.packages(as.character(x)))
lapply(packages, function(x) require(as.character(x), character.only = T))

# Get the directory of the file & set working directory
# filedir=dirname(rstudioapi::getSourceEditorContext()$path)
wd="~/Academic/PhD/diversity-determinants-recombination-landscapes-flowering-plants/"
setwd(wd)
# Custom functions
source(paste(wd, "sources/PhysMap.R", sep = "")) # Get the physical positions of a marker given a list of marker names
source(paste(wd, "sources/MareyMap.R", sep = "")) # Consolidate a MareyMap input file
source(paste(wd, "sources/core_pipeline.R", sep = "")) # Basic functions but essential for the pipeline (e.g. saving logs)
source(paste(wd, "sources/Genome.R", sep = "")) # Essential functions to parse GFF files and compute genomic statistics
```


```{r message = FALSE, warning = FALSE, include = FALSE}
# Loading data
genomes = read.table(paste(wd, "data/Genome/Genome_ressources.csv", sep = ""), header = TRUE, sep = ";")
metadata = read.table(paste(wd, "data/Genetic_maps/Genetic_maps_ressources.csv", sep = ""), header = TRUE, sep = ";")
metadata.clean = read.table(paste(wd, "data-cleaned/Genetic_maps_ressources.csv", sep = ""), header = TRUE, sep = ";")
chromosomes = read.table(paste(wd, "tables/chromosome.stats.csv", sep = ""), header = TRUE, sep = ";")
chromosomes$set = as.character(chromosomes$set)
chromosomes$chromosome = as.character(chromosomes$chromosome)

chromosome.stats = chromosomes

metadata.chromosomes = read.table(paste(wd, "data-cleaned/chromosomes_metadata.csv", sep = ""), header = TRUE, sep = "\t")

chromosome.stats$chromosome.size.bp = NA
for (i in 1:nrow(chromosome.stats)) {
  # cat(i, "\n")
  chrsize = metadata.chromosomes$chrsize.bp[which(metadata.chromosomes$set == chromosome.stats$set[i] & metadata.chromosomes$litteralname == chromosome.stats$chromosome[i])]
  if (!is.na(chrsize)) {
    chromosome.stats$chromosome.size.bp[i] = chrsize
  } else {
    chromosome.stats$chromosome.size.bp[i] = chromosome.stats$phys.map.length[i]
  }
}

# Convert physical size to megabases
# chromosome.stats$phys.map.length = chromosome.stats$phys.map.length/1000000
# Take the full genome assembly size instead of the last marker
chromosome.stats$phys.map.length = chromosome.stats$chromosome.size.bp/1000000
```


Save metadatas about the dataset.

```{r include = FALSE}
metadata.tmp = chromosome.stats[, c(1:2, 4:13, 23)]
metadata.tmp = merge(metadata.tmp, metadata.clean[, c(1, 14, 19, 20, 31, 32)],
                 by.x = "set", by.y =  "id")
meta = metadata.tmp[,1:2]
meta$chromosome.annotation = NA
for (i in 1:nrow(metadata)) {
  meta$chromosome.annotation[i] = metadata.chromosomes$annotname[which(metadata.chromosomes$litteralname == meta$chromosome[i] & metadata.chromosomes$set == meta$set[i])]
}
meta = cbind(meta, metadata.tmp[,3:ncol(metadata.tmp)])
rm(metadata.tmp)

write.xlsx(x = meta, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S1_Dataset_Metadata", row.names = FALSE)

df.species = metadata.clean[,c("id",  "species", "family", "ref", "year", "doi", "accession")]
df.species$species = gsub("_", " ", df.species$species)
df.species = df.species[order(df.species$species),]

write.xlsx(x = df.species, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S2_Species_Metadata", row.names = FALSE, append = TRUE)

karyotypes = readxl::read_xlsx(paste(wd, "data-cleaned/Karyotypes.xlsx", sep = ""))

write.xlsx(x = karyotypes, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S3_Centromeric_Index", row.names = TRUE, append = TRUE)
```

#### Figure S1

Save Marey maps in a Supplementary pdf...

```{r include = FALSE}
# Save all Marey maps and recombination maps in supplementary
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats), function(x) {
  # import recombination map
  mareymap = read.table(paste(wd, "data-cleaned/marey_maps/", chromosome.stats$set[x], ".txt", sep = ""),
                        header = TRUE)
  mareymap = subset(mareymap, mareymap$map == chromosome.stats$chromosome[x])
  # Make the figure as a ggplot object
  ggplot(data = mareymap, aes(x = phys/1000000, y = gen)) +
    ggtitle(paste(chromosome.stats$species[x], "chromosome", chromosome.stats$chromosome[x], sep = " ")) +
    geom_point() + # Add markers
    # Add centromere position
    geom_vline(aes(xintercept = chromosome.stats$centromere_position_estimated[x]), size = 1.2) +
    xlab("Genomic position (Mb)") + ylab("genetic distance (cM)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')
})

# Save list of plots
ggsave(filename = paste(wd, "figures/article_one/FigS1.pdf", sep = ""), 
   plot = marrangeGrob(p, nrow=1, ncol=1), 
   width = 10, height = 10
)
```




```{r include = FALSE}
# Save all Marey maps and recombination maps in supplementary
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats), function(x) {
  # import recombination map
  mareymap = read.table(paste(wd, "data-cleaned/marey_maps/", chromosome.stats$set[x], ".txt", sep = ""),
                        header = TRUE)
  mareymap = subset(mareymap, mareymap$map == chromosome.stats$chromosome[x])
  # Make the figure as a ggplot object
  ggplot(data = mareymap, aes(x = phys/1000000, y = gen)) +
    ggtitle(paste(chromosome.stats$species[x], "chromosome", chromosome.stats$chromosome[x], sep = " ")) +
    geom_point(size=0.5) + # Add markers
    # Add centromere position
    geom_vline(aes(xintercept = chromosome.stats$centromere_position_estimated[x]), size = 0.5) +
    xlab("Genomic position (Mb)") + ylab("genetic distance (cM)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=7, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=7),
        axis.title.y = element_text(color="black", size=7),
        axis.text=element_text(size=7, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_text(size=7),
        legend.position='right')
})

# Save list of plots
ggsave(filename = paste(wd, "figures/article_one/FigureS1_MareyMaps_compressed.pdf", sep = ""), 
   plot = marrangeGrob(p, nrow=1, ncol=1),  
   width = 5, height = 5, dpi = 75, useDingbats = TRUE
)
```


#### Figure S2

Save recombination maps in a Supplementary pdf...

```{r include = FALSE}
# Save all Marey maps and recombination maps in supplementary
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats), function(x) {
  # import recombination map
  # mareymap = read.table(paste(wd, "", sep = ""))
  recmap = read.table(paste(wd, "output/recombination_maps/loess/100kbwind/", chromosome.stats$set[x], "_chromosome", chromosome.stats$chromosome[x], ".txt", sep = ""), header = TRUE)
  # Regularize the minimum boundary of CI
  recmap$lower[which(recmap$rec.rate < recmap$lower)] = 0
  # Make the figure as a ggplot object
  ggplot(data = recmap, aes(x = phys, y = rec.rate)) +
    ggtitle(paste(chromosome.stats$species[x], "chromosome", chromosome.stats$chromosome[x], sep = " ")) +
    geom_line(size = 0.5) + # Add the recombination landscape
    # Add a confidence interval
    geom_ribbon(aes(x = phys, ymin = lower, ymax = upper), fill = "black", alpha = 0.2) +
    # Add centromere position
    geom_vline(aes(xintercept = chromosome.stats$centromere_position_estimated[x]), size = 0.5) +
    xlab("Genomic position (Mb)") + ylab("Recombination rate (cM/Mb)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=10, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=10),
        axis.title.y = element_text(color="black", size=10),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=10, face = "italic"),
        legend.title=element_text(size=10),
        legend.position='right')
})

# Save list of plots
ggsave(filename = paste(wd, "figures/article_one/FigS2.pdf", sep = ""), 
   plot = marrangeGrob(p, nrow=1, ncol=1), 
   width = 9, height = 5, dpi = 75, useDingbats = TRUE
)
```



```{r include = FALSE}
# Save all Marey maps and recombination maps in supplementary
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats), function(x) {
  # import recombination map
  # mareymap = read.table(paste(wd, "", sep = ""))
  recmap = read.table(paste(wd, "output/recombination_maps/loess/100kbwind/", chromosome.stats$set[x], "_chromosome", chromosome.stats$chromosome[x], ".txt", sep = ""), header = TRUE)
  # Regularize the minimum boundary of CI
  recmap$lower[which(recmap$rec.rate < recmap$lower)] = 0
  # Make the figure as a ggplot object
  ggplot(data = recmap, aes(x = phys, y = rec.rate)) +
    ggtitle(paste(chromosome.stats$species[x], "chromosome", chromosome.stats$chromosome[x], sep = " ")) +
    geom_line(size = 1.4) + # Add the recombination landscape
    # Add a confidence interval
    geom_ribbon(aes(x = phys, ymin = lower, ymax = upper), fill = "black", alpha = 0.2) +
    # Add centromere position
    geom_vline(aes(xintercept = chromosome.stats$centromere_position_estimated[x]), size = 1.2) +
    xlab("Genomic position (Mb)") + ylab("Recombination rate (cM/Mb)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')
})

# Save list of plots
ggsave(filename = paste(wd, "figures/article_one/FigureS2_RecombinationMaps.pdf", sep = ""), 
   plot = marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)
```





```{r echo = FALSE, message = FALSE, warning = FALSE}
#----------------------------------------------------------------------------
# Build the mixed model dataset
#----------------------------------------------------------------------------
lmm.data = cbind(data.frame(Species = gsub("_", " ", unlist(lapply(chromosome.stats$set, function(x){metadata.clean$species[which(as.character(metadata.clean$id) == as.character(x))]})))),
      chromosome.stats)

#----------------------------------------------------------------------------
# Build the phylogeny
#----------------------------------------------------------------------------
# Load the phylogenetic tree estimated in 'Phylogeny.R'
load(paste(wd, "output/phylogeny/tree.Rdata", sep = ""))

#----------------------------------------------------------------------------
# Build the traits dataset
#----------------------------------------------------------------------------
phylogenetic_traits = cbind(data.frame(Species = gsub("_", " ", unlist(lapply(chromosome.stats$set, function(x){metadata.clean$species[which(as.character(metadata.clean$id) == as.character(x))]})))),
                            chromosome.stats)
```

## Dataset quality

Assessment of recombination landscapes quality.


```{r echo = TRUE, message = FALSE, warning = FALSE, fig.align="center", fig.cap = "(ref:landscape-quality)"}
#============================================================================
# Quantitative assessment - Correlation between the chromosome wide recombination rate & the mean estimated recombination rate
# Show the linear relationship between chromosome wide rate and the mean estimated recombination rate as a cross-validation procedure
#============================================================================
plot(chromosomes$chrwide.rate, chromosomes$mean.recrate, xlab = "Chromosome-wide recombination rate",
     ylab = "Mean estimated recombination rate", cex = 1.2, cex.lab = 1.2, cex.axis = 1.2)
abline(a = 0, b = 1, col = "Red")
```

(ref:landscape-quality) Correlation between the chromosome wide recombination rate and the mean estimated recombination rate. Identity line drawn in red.





```{r include=FALSE}
fontsize = 10
pointsize = 2
linesize = 0.5

p = ggplot(data = chromosome.stats, aes(x = chrwide.rate, y = mean.recrate)) +
  geom_point(size = pointsize) +
  geom_segment(aes(x = 0, y = 0, xend = max(chrwide.rate, na.rm = TRUE), yend = max(mean.recrate, na.rm = TRUE)), size = linesize, colour = "Red") +
  xlab("Chromosome Wide Recombination Rate (cM/Mb)") +
  ylab("Averaged recombination rate (cM/Mb)") +
  geom_text(aes(x = 15, y = 20, label = "y = x"), colour = "Red") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')

ggsave(file = paste(wd, "figures/article_one/FigureReview1.tiff", sep = ""), plot = p, width = 5, height = 3, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigureReview1.jpeg", sep = ""), plot = p, width = 5, height = 3, dpi = 300)
```



```{r echo = TRUE, message = FALSE, warning = FALSE}
cor.test(chromosomes$chrwide.rate, chromosomes$mean.recrate, method = "spearman")
```

Correlation between recombination maps at 100kb and 1Mb.

```{r echo = FALSE}
# concat_files = function(x) {
#   df = read.table(x, header = TRUE)
#   set = gsub(".txt", "", gsub(paste(wd, "/output/recombination_maps/loess/[A-Za-z0-9]*bwind/", sep = ""), "", x))
#   df$dataset = set
#   return(df)
# }
# # Load all 100kb maps
# files = system(paste("ls ", wd, "/output/recombination_maps/loess/100kbwind/", sep = ""), intern = TRUE)
# files = paste(wd, "/output/recombination_maps/loess/100kbwind/", files[grep("*.txt", files)], sep = "")
# estimates100kb = bind_rows(lapply(files, function(x) concat_files(x)))
# estimates100kb$species = regmatches(estimates100kb$dataset, regexpr("^[A-Za-z0-9]*_[A-Za-z0-9]*", estimates100kb$dataset))
# estimates100kb$chromosome = gsub("_chromosome", "", regmatches(estimates100kb$dataset, regexpr("_chromosome[A-Za-z0-9]*$", estimates100kb$dataset)))
# 
# # Load all 1Mb maps
# files = system(paste("ls ", wd, "/output/recombination_maps/loess/1Mbwind/", sep = ""), intern = TRUE)
# files = paste(wd, "/output/recombination_maps/loess/1Mbwind/", files[grep("*.txt", files)], sep = "")
# estimates1Mb = bind_rows(lapply(files, function(x) concat_files(x)))
# estimates1Mb$species = regmatches(estimates1Mb$dataset, regexpr("^[A-Za-z0-9]*_[A-Za-z0-9]*", estimates1Mb$dataset))
# estimates1Mb$chromosome = gsub("_chromosome", "", regmatches(estimates1Mb$dataset, regexpr("_chromosome[A-Za-z0-9]*$", estimates1Mb$dataset)))
# 
# # Average 100kb recombination rates in windows of 1Mb
# estimates1Mb$average100kb = NA
# for (i in 1:nrow(estimates1Mb)) {
#   estimates1Mb$average100kb[i] = mean(estimates100kb$rec.rate[which(estimates100kb$dataset == estimates1Mb$dataset[i] & estimates100kb$chromosome == estimates1Mb$chromosome[i] & estimates100kb$phys >= (estimates1Mb$phys[i] - 0.5) & estimates100kb$phys <= (estimates1Mb$phys[i] + 0.5))], na.rm = TRUE)
# }
# # Save the result
# write.table(estimates1Mb, paste(wd, "output/correlation_maps_scales.txt", sep = ""), col.names = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
estimates1Mb = read.table(paste(wd, "output/correlation_maps_scales.txt", sep = ""), header = TRUE)
```

```{r echo = TRUE}
# Correlation
cor.test(estimates1Mb$rec.rate, estimates1Mb$average100kb, method = "spearman")
plot(estimates1Mb$rec.rate, estimates1Mb$average100kb)
```

```{r include = FALSE}
# Correlation per species/dataset
sp_corr = data.frame(species = unique(estimates1Mb$species))
sp_corr$n_windows = NA
sp_corr$corr = NA
sp_corr$statistic = NA
sp_corr$p.value = NA
for (i in 1:nrow(sp_corr)) {
  sp_corr$n_windows[i] = length(which(estimates1Mb$species == sp_corr$species[i]))
  
  sp_corr$statistic[i] = cor.test(estimates1Mb$rec.rate[which(estimates1Mb$species == sp_corr$species[i])], estimates1Mb$average100kb[which(estimates1Mb$species == sp_corr$species[i])], method = "spearman")$statistic
  
  sp_corr$p.value[i] = cor.test(estimates1Mb$rec.rate[which(estimates1Mb$species == sp_corr$species[i])], estimates1Mb$average100kb[which(estimates1Mb$species == sp_corr$species[i])], method = "spearman")$p.value
  
  sp_corr$corr[i] = cor.test(estimates1Mb$rec.rate[which(estimates1Mb$species == sp_corr$species[i])], estimates1Mb$average100kb[which(estimates1Mb$species == sp_corr$species[i])], method = "spearman")$estimate
}

# Correlation per chromosome
# chr_corr = data.frame(dataset = unique(estimates1Mb$dataset))
# chr_corr$corr = NA
# for (i in 1:nrow(chr_corr)) {
#   chr_corr$corr[i] = cor.test(estimates1Mb$rec.rate[which(estimates1Mb$dataset == chr_corr$dataset[i])], estimates1Mb$average100kb[which(estimates1Mb$dataset == chr_corr$dataset[i])], method = "spearman")$estimate
# }

# Save the table of correlation per species/dataset

```

```{r echo = TRUE}
sp_corr$species = gsub("_", " ", sp_corr$species)
colnames(sp_corr) = c("Species", "Number of 1Mb windows", "Rho", "Statistic", "p-value")
kable(sp_corr, digits = 3, align = "c")
# Save the table of correlation per species/dataset
write.xlsx(x = sp_corr, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S4_MareyMaps_CorrelationScales", row.names = FALSE, append = TRUE)
```


### Correction of the linkage map length uncorrected/corrected (map coverage)

Two methods to correct linkage map length
1. Chakravarti et al. (1991) 
2. Hall and Willis (2005)


<!-- ```{r echo = TRUE} -->
<!-- # Two methods to correct linkage map length -->
<!-- # 1. Chakravarti et al. (1991) -->
<!-- cor.test(chromosome.stats$linkage.map.length, chromosome.stats$linkage.map.length.correctedCh, method = "spearman") -->
<!-- plot(chromosome.stats$linkage.map.length, chromosome.stats$linkage.map.length.correctedCh,  -->
<!--      xlab = "Linkage map length (uncorrected)", -->
<!--      ylab = "Linkage map length (corrected)") -->

<!-- #  2. Hall and Willis (2005) -->
<!-- cor.test(chromosome.stats$linkage.map.length, chromosome.stats$linkage.map.length.correctedHW, method = "spearman") -->
<!-- plot(chromosome.stats$linkage.map.length, chromosome.stats$linkage.map.length.correctedHW,  -->
<!--      xlab = "Linkage map length (uncorrected)", -->
<!--      ylab = "Linkage map length (corrected)") -->
<!-- ``` -->


Corrected linkkage map length don't change significantly the raw linkage map length.

```{r echo = TRUE}
corr_linkagemap = chromosome.stats$linkage.map.length - chromosome.stats$linkage.map.length.correctedHW
summary(corr_linkagemap)


n.boot = 1000
boot = numeric(n.boot)
for (i in 1:n.boot) {
  boot[i] = mean(sample(corr_linkagemap, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot , c(0.025, 0.975))
```


### Genome coverage


```{r echo = TRUE}
# The difference between genomic map length (Mb) in the Marey map and the total chromosome size from the fasta file.
summary(chromosome.stats$phys.map.length*10^6 - chromosome.stats$chromosome.size.bp)
```



### Marker density

Number of markers

```{r echo = TRUE}
summary(chromosome.stats$nb.markers)
hist(chromosome.stats$nb.markers, breaks = 300, main = "", xlab = "Number of markers")
hist(chromosome.stats$nb.markers, breaks = 30000, xlim = c(0,1000), main = "", xlab = "Number of markers")
```


Marker density (nb of markers/total map length); i.e. the averaged number of markers per cM/Mb, more is better.

```{r echo = TRUE}
summary(chromosome.stats$density.markers.cM)
hist(chromosome.stats$density.markers.cM, breaks = 80, main = "", xlab = "Marker density (cM)")
```


```{r echo = TRUE}
summary(chromosome.stats$density.markers.bp*10^6)
hist(chromosome.stats$density.markers.bp*10^6, breaks = 80, main = "", xlab = "Marker density (Mb)")
hist(chromosome.stats$density.markers.bp*10^6, breaks = 800, main = "", xlab = "Marker density (Mb)", xlim = c(0, 100))
```

Mean interval between markers (cM/Mb)

TODO - median interval (less sensitive to extreme values, i.e. large gaps)

```{r echo = TRUE}
summary(chromosome.stats$marker.interval.cM)
hist(chromosome.stats$marker.interval.cM, breaks = 80, main = "", xlab = "Mean interval between adjacent markers (cM)")
```


```{r echo = TRUE}
summary(chromosome.stats$marker.interval.bp/10^6)
hist(chromosome.stats$marker.interval.bp/10^6, breaks = 80, main = "", xlab = "Mean interval between adjacent markers (Mb)")
hist(chromosome.stats$marker.interval.bp/10^6, breaks = 80, main = "", xlab = "Mean interval between adjacent markers (Mb)", xlim = c(0, 2))
```



### How many maps discarded

Number of dataset discarded.


Number of chromosomes discarded among retained dataset.

```{r echo = TRUE}
maps = read.table(file = paste0(wd, "/data-cleaned/marey_maps/AllMaps.txt"), header = TRUE, sep = "\t")

# All chromosomes - import Marey maps
set_list = paste(wd, "/data-cleaned/marey_maps/", unique(maps$set), ".txt", sep = "")
allmaps = do.call("rbind", lapply(set_list, FUN = function(file) {
  read.table(file, header=TRUE, sep="\t")
}))
# Chromosomes in dataset
length(unique(paste(allmaps$set, allmaps$map, sep = "_")))

# Chromosomes retained
length(unique(paste(maps$set[which(maps$vld)], maps$map[which(maps$vld)], sep = "_")))

```




## Phylogeny

Phylogenetic tree of sampled species.

```{r echo = FALSE, message = FALSE, warning = FALSE, include = TRUE}
# Load the phylogenetic tree estimated in 'Phylogeny.R'
load(paste(wd, "output/phylogeny/tree.Rdata", sep = ""))

# Root the phylogeny on Nelumbo nucifera
ape::root(tree, outgroup = "Nelumbo nucifera")

# Add annotations
# e.g. mean recombination rate, mean chromosome size
annotation = data.frame(species = tree$tip.label)
annotation$REC = NA
annotation$CHRSIZE = NA
for (i in 1:nrow(annotation)) {
  annotation$REC[i] = (mean(chromosome.stats$mean.recrate[which(chromosome.stats$species == annotation$species[i])], na.rm = TRUE))
  annotation$CHRSIZE[i] = (mean(chromosome.stats$phys.map.length[which(chromosome.stats$species == annotation$species[i])], na.rm = TRUE))
}
rownames(annotation) = annotation$species
annotation = as.data.frame(annotation[,-1])
colnames(annotation) = c("REC", "CHRSIZE")
```

#### Figure S3

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 28, fig.width = 32, fig.align="center", fig.cap = "(ref:phylogenetic-tree-annotated)"}
# Make the tree
p1 = ggtree(tree, aes(),layout = 'fan', open.angle = 30, size = 3) +
  xlim(0,300) +
  geom_tiplab(aes(), fontface = "italic", size = 20, offset = 20)
# p1

p2 = gheatmap(p1, annotation[,"REC", drop = FALSE], offset=0, width=.05,
         colnames_angle=90, colnames_offset_y = 61, font.size = 12) +
  scale_fill_viridis_c(option = "D", name = "REC", breaks = c(0.5, 1, 2, 4, 8, 16),
                       labels = c(0.5, 1, 2, 4, 8, 16),
                       trans = scales::pseudo_log_trans(sigma = 0.001))
# p2
p3 = p2 + new_scale_fill()
p3 = gheatmap(p3, annotation[,"CHRSIZE", drop = FALSE], offset=8, width=.05,
              colnames_angle=90, colnames_offset_y = 61, font.size = 12) +
  scale_fill_viridis_c(option = "C", name = "CHRSIZE", direction = -1,
                       breaks = c(10, 20, 40, 80, 160, 320, 640),
                       trans = scales::pseudo_log_trans(sigma = 0.001)) +
  theme(legend.text = element_text(size = 40),
        legend.title = element_text(size = 40),
        legend.key.size = unit(2, 'cm'))
p3

# Change topology with Nelumbo in outgroup
# ggtree(tree) + geom_text(aes(label=node))
# gridExtra::grid.arrange(p3, flip(p3, 101, 57))
# p3
```

(ref:phylogenetic-tree-annotated) Phylogenetic tree representing sampled species and annotated with mean recombination rates and mean chromosome sizes.


```{r include=FALSE}
fontsize = 4

# Make the tree
p1 = ggtree(tree, aes(),layout = 'fan', open.angle = 30, size = 0.7) +
  xlim(0,300) +
  geom_tiplab(aes(), fontface = "italic", size = fontsize, offset = 20) +
  theme(plot.margin = margin(l = 1, unit = "cm"))
# p1

p2 = gheatmap(p1, annotation[,"REC", drop = FALSE], offset=0, width=.05,
         colnames_angle=90, colnames_offset_y = 61, font.size = 0) +
  scale_fill_viridis_c(option = "D", name = "REC", breaks = c(0.5, 1, 2, 4, 8, 16),
                       labels = c(0.5, 1, 2, 4, 8, 16),
                       trans = scales::pseudo_log_trans(sigma = 0.001))
# p2
p3 = p2 + new_scale_fill()
p3 = gheatmap(p3, annotation[,"CHRSIZE", drop = FALSE], offset=8, width=.05,
              colnames_angle=90, colnames_offset_y = 61, font.size = 0) +
  scale_fill_viridis_c(option = "C", name = "CHRSIZE", direction = -1,
                       breaks = c(10, 20, 40, 80, 160, 320, 640),
                       trans = scales::pseudo_log_trans(sigma = 0.001)) +
  theme(legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        legend.key.size = unit(0.5, 'cm'))
p3

ggsave(file = paste(wd, "figures/article_one/FigS3.tiff", sep = ""), plot = p3, width = 7, height = 6, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS3.jpeg", sep = ""), plot = p3, width = 7, height = 6, dpi = 300)
```



## Life history traits

### Mating system

```{r echo = TRUE}
lht = openxlsx::read.xlsx(paste(wd, "data-cleaned/ListPlant_Thomas.xlsx", sep = ""), sheet = 1)
lht$sp = paste(lht$Genus, " ", lht$Species, sep = "")
chr_lht = chromosome.stats
chr_lht$mating = NA
for (i in 1:nrow(chr_lht)) {
  chr_lht$mating[i] = lht$Mating_system[which(lht$sp == chr_lht$species[i])]
}
lht$recrate = NA
lht$linkagemaplength = NA
for (i in 1:nrow(lht)) {
  lht$recrate[i] = mean(chr_lht$mean.recrate[which(chr_lht$species == lht$sp[i])], na.rm = TRUE)
  lht$linkagemaplength[i] = mean(chr_lht$linkage.map.length.correctedHW[which(chr_lht$species == lht$sp[i])], na.rm = TRUE)
}
# Sample sizes
table(lht$Mating_system)
table(chr_lht$mating)

boxplot(recrate ~ Mating_system, data = lht,
        xlab = "Mean recombination rate", ylab = "Linkage map length (cM)")
kruskal.test(recrate ~ Mating_system, data = lht)

boxplot(linkagemaplength ~ Mating_system, data = lht,
        xlab = "Mating system", ylab = "Linkage map length (cM)")
kruskal.test(linkagemaplength ~ Mating_system, data = lht)


boxplot(mean.recrate ~ mating, data = chr_lht,
        xlab = "Mean recombination rate", ylab = "Linkage map length (cM)")

boxplot(linkage.map.length ~ mating, data = chr_lht,
        xlab = "Mating system", ylab = "Linkage map length (cM)")

```


## Position of the centromeric index on the genome


False Positive Rate. How many centromeric indexes have been assigned to the wrong side of the chromosome? Compare the recombination rate at the centromeric index with the putative position on the opposite direction, thus the FPR is the percentage of CI that have a higher recombination rate than the opposite position.


```{r echo = FALSE}
scale = 10^6
# Orient the Centromeric Index based on the putative centromere position
df = data.frame(set = chromosome.stats$set, chromosome = chromosome.stats$chromosome)
df$centromeric_index = chromosome.stats$centromeric_index
df$centromere_position_estimated = chromosome.stats$centromere_position_estimated
df$phys.map.length = chromosome.stats$phys.map.length

df$centromeric_index_position_oriented = NA
df$centromeric_index_position_opposite = NA
for (i in 1:nrow(df)) {
  # cat("Dataset", df$set[i], "chromosome", df$chromosome[i], "\n")
  # If the ratio with centromere position is lower than 0.5,
  # then the CI and the centromere inferred are oriented the same way
  centromere_position = df$centromere_position_estimated[i]
  if (centromere_position / max(df$phys.map.length[i], na.rm = TRUE) < 0.5) {
    # The true position estimated
    CI = df$centromeric_index[i]*df$phys.map.length[i]
    # The opposite position
    CI_opposite = (1 - df$centromeric_index[i])*df$phys.map.length[i]
  } else {
    CI = (1 - df$centromeric_index[i])*df$phys.map.length[i]
    CI_opposite = df$centromeric_index[i]*df$phys.map.length[i]
  }
  df$centromeric_index_position_oriented[i] = CI
  df$centromeric_index_position_opposite[i] = CI_opposite
}

df$true_CI_rate = NA
df$false_CI_rate = NA
# Recombination rate at each position
for (i in 1:nrow(df)) {
  if (!is.na(df$centromeric_index_position_oriented[i]) & !is.na(df$centromeric_index_position_opposite[i])) {
    map = read.table(paste(wd, "output/recombination_maps/loess/100kbwind/", df$set[i], "_chromosome", df$chromosome[i], ".txt", sep = ""), header = TRUE)
    if (df$centromeric_index_position_oriented[i] < max(map$phys, na.rm = TRUE)) {
      df$true_CI_rate[i] = map$rec.rate[which((map$phys - 0.05) < df$centromeric_index_position_oriented[i] & (map$phys + 0.05) > df$centromeric_index_position_oriented[i])]
    }
    if (df$centromeric_index_position_opposite[i] < max(map$phys, na.rm = TRUE)) {
      df$false_CI_rate[i] = map$rec.rate[which((map$phys - 0.05) < df$centromeric_index_position_opposite[i] & (map$phys + 0.05) > df$centromeric_index_position_opposite[i])]
    }
  }
}
```


```{r echo = TRUE}
sum(!is.na(df$true_CI_rate))
# Number of centromeric indexes wrongly oriented (i.e. lower recombination rate on the opposite position)
sum(df$true_CI_rate > df$false_CI_rate, na.rm = TRUE)
# Proportion -> the FPR
sum(df$true_CI_rate > df$false_CI_rate, na.rm = TRUE)/sum(!is.na(df$true_CI_rate))

# Identify these chromosomes to put them asides
idx_wrongCIorientation = which(df$true_CI_rate > df$false_CI_rate)
paste(df$set[which(df$true_CI_rate > df$false_CI_rate)], df$chromosome[which(df$true_CI_rate > df$false_CI_rate)])

# The distribution of differences
# Values below 0 indicates that recombination rates are lower on the opposite position
hist(df$false_CI_rate - df$true_CI_rate, main = "", xlab = "Differences inferred/alternative centromere position", breaks = 30)

# How many of wrongly oriented CI have a small difference between true and false position? e.g. less than 0.5 cM/Mb
threshold = 1
sum(df$true_CI_rate > df$false_CI_rate & (df$false_CI_rate - df$true_CI_rate) > -threshold, na.rm = TRUE)
sum(df$true_CI_rate > df$false_CI_rate & (df$false_CI_rate - df$true_CI_rate) > -threshold, na.rm = TRUE)/sum(df$true_CI_rate > df$false_CI_rate, na.rm = TRUE)
```



# Smaller chromosomes recombine more than larger ones

Test the correlation between chromosome size and recombination rate.

```{r echo = TRUE}
# Sample size
nrow(chromosome.stats)
```


How many chromosomes with less than one CO?

```{r echo = TRUE}
length(which(chromosome.stats$linkage.map.length < 50))

# proportion
length(which(chromosome.stats$linkage.map.length < 50))/nrow(chromosome.stats)
```

How often do chromosome arms have multiple crossovers, versus a single one?
```{r echo = TRUE}
length(which(chromosome.stats$linkage.map.length > 50 & chromosome.stats$linkage.map.length < 100))

length(which(chromosome.stats$linkage.map.length > 100))

# proportion
length(which(chromosome.stats$linkage.map.length < 50))/nrow(chromosome.stats)
```




```{r echo = TRUE}
# Spearman correlation
cor.test(chromosome.stats$phys.map.length, chromosome.stats$mean.recrate, method = "spearman")

# Spearman correlation with Phylogenetically Independent Contrasts
# cor_phylo(log10(mean.recrate) ~ log10(phys.map.length), data = phylogenetic_traits, species = phylogenetic_traits$Species, phy = tree)

# Test the correlation with PGLMM
pglmm_mod = pglmm(log10(mean.recrate) ~ log10(phys.map.length) + (1|Species__), data = phylogenetic_traits, family = 'gaussian', cov_ranef = list(Species = tree))

summary(pglmm_mod)
```


### Model selection to identify the model that best fit the data.

```{r echo = FALSE, message = FALSE, warning = FALSE}
# MODEL SELECTION, based on AIC/BIC
# Table with AIC/BIC
nmodels = 4
model_selection  =data.frame(model = character(nmodels),
         formula = character(nmodels),
         AIC = numeric(nmodels),
         BIC = numeric(nmodels))

lm.model = lm(log10(mean.recrate) ~ log10(phys.map.length), data = lmm.data)
model_selection$model[1] = "LM"
model_selection$formula[1] = paste(as.character(formula(lm.model))[2], as.character(formula(lm.model))[1], as.character(formula(lm.model))[3], sep = " ")
model_selection$AIC[1] = AIC(lm.model)
model_selection$BIC[1] = BIC(lm.model)

lmer.model = lmer(log10(mean.recrate) ~ log10(phys.map.length) + (1|Species), data = lmm.data)
model_selection$model[2] = "LMER"
model_selection$formula[2] = paste(as.character(formula(lmer.model))[2], as.character(formula(lmer.model))[1], as.character(formula(lmer.model))[3], sep = " ")
model_selection$AIC[2] = AIC(lmer.model)
model_selection$BIC[2] = BIC(lmer.model)

lmer.model = lmer(log10(mean.recrate) ~ log10(phys.map.length) + (log10(phys.map.length)|Species), data = lmm.data)
model_selection$model[3] = "LMER"
model_selection$formula[3] = paste(as.character(formula(lmer.model))[2], as.character(formula(lmer.model))[1], as.character(formula(lmer.model))[3], sep = " ")
model_selection$AIC[3] = AIC(lmer.model)
model_selection$BIC[3] = BIC(lmer.model)

pglmm.model = pglmm(log10(mean.recrate) ~ log10(phys.map.length) + (1|Species),
                    data = phylogenetic_traits,
                    family = 'gaussian',
                    cov_ranef = list(Species = tree))
model_selection$model[4] = "PGLMM"
model_selection$formula[4] = paste(as.character(formula(pglmm.model))[2], as.character(formula(pglmm.model))[1], as.character(formula(pglmm.model))[3], "+ (1|Species__)", sep = " ")
model_selection$AIC[4] = pglmm.model$AIC
model_selection$BIC[4] = pglmm.model$BIC

kable(model_selection, caption = "Model selection based on AIC/BIC", labels = c("Model", "Formula", "AIC", "BIC"), align = "c")
```


```{r echo = TRUE}
write.xlsx(x = model_selection, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S5_ModelSelection", row.names = FALSE,
           append = TRUE)
```





### Representing the relationship between chromosome size and recombination rate.



```{r echo = FALSE}
#============================================================================
# Figure. Mean recombination rate (log scale) as a function of physical length (log scale) for each chromosome
#============================================================================
df = data.frame(phys.map.length = chromosome.stats$phys.map.length, mean.recrate = chromosome.stats$mean.recrate, species = chromosome.stats$species)
# ncolors = nlevels(as.factor(chromosome.stats$species))
# color.species = viridis(ncolors)
# div_col_pals = brewer.pal.info[brewer.pal.info$category == 'div',]
# color.species = unlist(mapply(brewer.pal, div_col_pals$maxcolors, rownames(div_col_pals)))[1:ncolors]

#----------------------------------------------------------------------------
# Mean recombination rate ~ Chromosome size
#----------------------------------------------------------------------------
# Linear regression fit
mod = lm(log10(chromosome.stats$mean.recrate) ~ log10(phys.map.length), data = chromosome.stats)
summary(mod)
# LMER
lmer.model = lmer(log10(mean.recrate)~log10(phys.map.length) + (1|species), data = chromosome.stats)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```

#### Figure 1


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 20, fig.align="center", fig.cap = "(ref:meanrecrate)"}
nb.cols = nlevels(as.factor(chromosome.stats$species))
set.seed(42)
color.species = sample(colorRampPalette(c(viridis(16), magma(16), brewer.pal(11, "Spectral")))(nb.cols), replace = FALSE)
# Simulate the expected regression line under the assumption of one CO per chromosome (i.e. a genetic length of 50cM)
expectedline = 100/(chromosome.stats$phys.map.length)

expect = data.frame(chrsize_expectations = seq(1, 2000, by = 1))

meanrec_chrsize = ggplot(data = chromosome.stats, aes(x = log10(phys.map.length), y = log10(mean.recrate))) +
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(50/chrsize_expectations))) +
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(100/chrsize_expectations))) +
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(150/chrsize_expectations))) +
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(200/chrsize_expectations))) +
  geom_point(aes(fill = species), pch = 21) +
  scale_fill_manual(values = color.species) +
  # scale_fill_npg() +
  # coord_trans(x = "log10", y = "log10") +
  scale_x_continuous(breaks = log10(c(5, 20, 100, 200, 500, 1000)), labels = c(5, 20, 100, 200, 500, 1000), limits = log10(c(2.5, 1000))) +
  scale_y_continuous(breaks = log10(c(0.2, 0.5, 2, 4, 8, 16)), labels = as.character(c(0.2, 0.5, 2, 4, 8, 16)), limits = log10(c(0.1, 32))) +
  xlab("Chromosome size (Mb)") + ylab("Chromosome recombination rate (cM/Mb)") +
  # geom_segment(aes(x = log10(3), y = log10(50/3), xend = log10(1000), yend = log10(50/1000)), colour = "blue") +
  # geom_abline(intercept = 50, slope = -1, colour = "blue") +
  # geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(50/(chrsize_expectations))), colour = "Red", linetype = "solid", size = 1.2) + # The expected regression line
  # geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(100/(chrsize_expectations))), colour = "Red", linetype = "dashed", size = 1.2) + # The expected regression line
  # geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(150/(chrsize_expectations))), colour = "Red", linetype = "dashed", size = 1.2) + # The expected regression line
  # geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(200/(chrsize_expectations))), colour = "Red", linetype = "dashed", size = 1.2) + # The expected regression line
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = 1.2) + # The linear regression line
  # geom_abline(intercept = fixef(lmer.model)[[1]], slope = fixef(lmer.model)[[2]], size = 1.2) + # The LMM regression line
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# meanrec_chrsize

#----------------------------------------------------------------------------
# Plot random slopes per species
# list_species = as.character(unique(chromosome.stats$species)[table(chromosome.stats$species) > 4])
# chromosome.stats_subset = subset(chromosome.stats, species %in% list_species)
# chromosome.stats_subset$species = as.character(chromosome.stats_subset$species)
# chromosome.stats_subset$chrsize = log(chromosome.stats_subset$phys.map.length)
# chromosome.stats_subset$meanreclog = log(chromosome.stats_subset$mean.recrate)
# Color palette
# ncolors = nlevels(as.factor(chromosome.stats_subset$species))
# div_col_pals = brewer.pal.info[brewer.pal.info$category == 'div',]
# color.species = unlist(mapply(brewer.pal, div_col_pals$maxcolors, rownames(div_col_pals)))[1:ncolors]

# mixed.model = lmer(log10(mean.recrate)~log10(phys.map.length) + (log10(phys.map.length)|species),
#                    data = chromosome.stats_subset)
# # Boundaries of random segments (mean of x values Â± e^0.5)
# boundaries = data.frame(species = rownames(coef(mixed.model)$species), upper = NA, lower = NA, color = NA)
# chromosome.stats$species = as.character(chromosome.stats$species)
# boundaries$species = as.character(boundaries$species)
# for (i in 1:nrow(boundaries)) {
#   boundaries$upper[i] = log10(max(chromosome.stats$phys.map.length[which(chromosome.stats$species == boundaries$species[i])], na.rm = TRUE))
#   boundaries$lower[i] = log10(min(chromosome.stats$phys.map.length[which(chromosome.stats$species == boundaries$species[i])], na.rm = TRUE))
  # boundaries$upper[i] = log10(mean(chromosome.stats$phys.map.length[which(chromosome.stats$species == boundaries$species[i])], na.rm = TRUE)) + 0.5
  # boundaries$lower[i] = log10(mean(chromosome.stats$phys.map.length[which(chromosome.stats$species == boundaries$species[i])], na.rm = TRUE)) - 0.5
  # Add the same colors as in previous ggplot
#   boundaries$color[i] = color.species[which(levels(as.factor(chromosome.stats_subset$species)) == boundaries$species[i])]
# }

# Subset only species with at least 4 chromosomes
list.species = as.character(unique(chromosome.stats$species)[table(chromosome.stats$species) > 4])
idx.species = as.numeric(which(table(chromosome.stats$species) > 4)) 
idx.chr = which(chromosome.stats$species %in% list.species)
  
meanrec_chrsize_randomslopes = ggplot(data = chromosome.stats[idx.chr,], aes(x = log10(phys.map.length), y = log10(mean.recrate))) +
  geom_point(aes(fill = species), pch = 21, alpha = 0.5) +
  geom_smooth(aes(color = species), method = "lm", se = FALSE) +
  scale_fill_manual(values = color.species[idx.species]) +
  scale_color_manual(values = color.species[idx.species]) +
  # scale_fill_npg() +
  # scale_color_npg() +
  # coord_trans(x = "log10", y = "log10") +
  scale_x_continuous(breaks = log10(c(5, 20, 100, 200, 500, 1000)), labels = c(5, 20, 100, 200, 500, 1000), limits = log10(c(3, 1000))) +
  scale_y_continuous(breaks = log10(c(0.2, 0.5, 2, 4, 8, 16)), labels = as.character(c(0.2, 0.5, 2, 4, 8, 16)), limits = log10(c(0.1, 16))) +
  xlab("Chromosome size (Mb)") + ylab("Chromosome recombination rate (cM/Mb)") +
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = 1.2) + # The linear regression line
  geom_abline(intercept = fixef(pglmm.model)[[1]][1], slope = fixef(pglmm.model)[[1]][2], linetype = "twodash", size = 1.2) + # The PGLMM regression line
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')

# # Adding random effects to the plot
# ranint = coef(mixed.model)$species[,1] # Random intercepts
# ranslope = coef(mixed.model)$species[,2] # Random slopes
# # Add random slopes
# for (i in 1:length(ranint)) {
#   meanrec_chrsize_randomslopes = meanrec_chrsize_randomslopes +
#     geom_segment(x = boundaries$lower[i], xend = boundaries$upper[i],
#                  y = ranint[i] + ranslope[i]*boundaries$lower[i],
#                  yend = ranint[i] + ranslope[i]*boundaries$upper[i],
#                  colour = boundaries$color[i])
# }

# meanrec_chrsize_randomslopes

ggpubr::ggarrange(meanrec_chrsize, meanrec_chrsize_randomslopes, ncol = 2, labels = "AUTO")
```

(ref:meanrecrate) (ref:meanrecrate) Negative correlation of recombination rates (cM/Mb, log scale) with chromosome size (Mb, log scale). Recombination rates were estimated with loess regression in windows of 100kb. Each point represents a chromosome (n=665). Species are presented in different colors (57 species). (A) The black solid line represents the linear model regression line fitted to the data. The expected simulated regression line is in red, assuming on average two crossovers per chromosome for the solid line (100cM), within an interval of 1 to 3 crossovers per chromosome (respectively lower and upper dashed red lines). (B) Within species relationships between recombination rates and chromosome size. The black dashed line represents the selected Linear Mixed Model (LMER). Colored lines for species random regressions.


```{r message=FALSE, warning=FALSE, include=FALSE}
fontsize = 10
dotsize = 0.2
linesize = 0.6
expect = data.frame(chrsize_expectations = seq(1, 2000, by = 1))

annot = data.frame(x = log10(c(10, 2, 4, 5.5, 8, 200)), y = log10(c(1, 32, 32, 32, 32, 8)), label = c("Less than 1 CO", "1", "2", "3", "4", "More than 4 COs"))

meanrec_chrsize = ggplot(data = chromosome.stats, aes(x = log10(phys.map.length), y = log10(mean.recrate))) +
  geom_point(aes(color = species), pch = 19, size = dotsize) +
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(50/(chrsize_expectations))), colour = "black", linetype = "solid", size = linesize/2) + # The expected regression line
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(100/(chrsize_expectations))), colour = "black", linetype = "solid", size = linesize/2) + # The expected regression line
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(150/(chrsize_expectations))), colour = "black", linetype = "solid", size = linesize/2) + # The expected regression line
  geom_line(data = expect, aes(x = log10(chrsize_expectations), y = log10(200/(chrsize_expectations))), colour = "black", linetype = "solid", size = linesize/2) +
  geom_text(data = annot, aes(x = x, y = y, label = label), size = 3) +
# The expected regression line
  scale_color_manual(values = color.species) +
  coord_cartesian(xlim = log10(c(2.5, 1000)), ylim = log10(c(0.1, 32))) +
  # scale_fill_npg() +
  # coord_trans(x = "log10", y = "log10") +
  scale_x_continuous(breaks = log10(c(5, 20, 100, 200, 500, 1000)), labels = c(5, 20, 100, 200, 500, 1000)) +
  scale_y_continuous(breaks = log10(c(0.2, 0.5, 2, 4, 8, 16)), labels = as.character(c(0.2, 0.5, 2, 4, 8, 16))) +
  xlab("Chromosome size (Mb)") + ylab("Recombination rate (cM/Mb)") +
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = linesize) + # The linear regression line
  # geom_abline(intercept = fixef(lmer.model)[[1]], slope = fixef(lmer.model)[[2]], size = 1.2) + # The LMM regression line
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')
# meanrec_chrsize

# Subset only species with at least 4 chromosomes
list.species = as.character(unique(chromosome.stats$species)[table(chromosome.stats$species) > 4])
idx.species = as.numeric(which(table(chromosome.stats$species) > 4)) 
idx.chr = which(chromosome.stats$species %in% list.species)
  
meanrec_chrsize_randomslopes = ggplot(data = chromosome.stats[idx.chr,], aes(x = log10(phys.map.length), y = log10(mean.recrate))) +
  # geom_point(aes(color = species), pch = 19, alpha = 0.5, size = dotsize) +
  geom_smooth(aes(color = species), method = "lm", se = FALSE, size = 0.3) +
  scale_color_manual(values = color.species[idx.species]) +
  # scale_fill_npg() +
  # scale_color_npg() +
  # coord_trans(x = "log10", y = "log10") +
  scale_x_continuous(breaks = log10(c(5, 20, 100, 200, 500, 1000)), labels = c(5, 20, 100, 200, 500, 1000), limits = log10(c(2.5, 1000))) +
  scale_y_continuous(breaks = log10(c(0.2, 0.5, 2, 4, 8, 16)), labels = as.character(c(0.2, 0.5, 2, 4, 8, 16)), limits = log10(c(0.1, 32))) +
  xlab("Chromosome size (Mb)") + ylab("Recombination rate (cM/Mb)") +
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = linesize) + # The linear regression line
  geom_abline(intercept = fixef(pglmm.model)[[1]][1], slope = fixef(pglmm.model)[[1]][2], linetype = "twodash", size = linesize) + # The PGLMM regression line
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')

tiffPlot = ggpubr::ggarrange(meanrec_chrsize, meanrec_chrsize_randomslopes, ncol = 2, labels = "AUTO", font.label = list(size = 9))+
  theme(plot.margin = margin(0,0,0,0, "cm"))
ggsave(file = paste(wd, "figures/article_one/Fig1.tiff", sep = ""), plot = tiffPlot, width = 7.5, height = 3, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig1.jpeg", sep = ""), plot = tiffPlot, width = 7.5, height = 3, dpi = 300)
```


### Relationship between linkage map length and chromosome length. Linkage map length is a measure of the absolute number of crossover per chromosome.

```{r echo = TRUE, message = FALSE, warning = FALSE}
cor.test(chromosomes$phys.map.length, chromosomes$linkage.map.length.correctedHW, method = "spearman")
```

```{r echo = FALSE, message = FALSE, warning = FALSE}
dataChrom <- read.table(paste(wd, "tables/chromosome.stats.csv", sep = ""), header = TRUE, sep = ";")
dataChrom$phys.map.length = dataChrom$phys.map.length/10^6
# Characteristics at the species level
dataSpecies <- aggregate(dataChrom$chromosome,list(species = dataChrom$species),length)
dataSpecies <- cbind(dataSpecies,aggregate(dataChrom$phys.map.length,list(species = dataChrom$species),sum)[2])
dataSpecies <- cbind(dataSpecies,aggregate(dataChrom$linkage.map.length,list(species = dataChrom$species),sum)[2])
names(dataSpecies) <- c("species","NbChrom","GenomeSize","GenetMapLength")
dataSpecies$MeanRec <- 10^6*dataSpecies$GenetMapLength/dataSpecies$GenomeSize
dataSpecies$MeanChromSize <- dataSpecies$GenomeSize/dataSpecies$NbChrom
dataSpecies$MeanChromMap <- dataSpecies$GenetMapLength/dataSpecies$NbChrom
```



```{r echo = FALSE, message = FALSE, warning = FALSE}
# For each species, regression between the linkage map and the physical map
# The intercept and the slope are retrieved
tmp <- by(dataChrom,dataChrom$species,function(x) lm(linkage.map.length.correctedHW ~ phys.map.length,data=x))
coef.reg <- sapply(tmp,coef)
dataSpecies$intercept1 <- coef.reg[1,]
dataSpecies$slope1 <- coef.reg[2,]
# The same with the log-log regression between recombination rate and physical map
# tmp <- by(dataChrom,dataChrom$species,function(x) lm(log(mean.recrate)~log(phys.map.length),data=x))
# coef.reg <- sapply(tmp,coef)
# dataSpecies$intercept2 <- coef.reg[1,]
# dataSpecies$slope2 <- coef.reg[2,]
# The few set with three chromosomes or less are excluded
# dataSpecies <- dataSpecies[dataSpecies$NbChrom>3,]

# Then the species statistics are added to the initial dataset
mydata <- merge(dataChrom,dataSpecies,by="species")

# A statistics used later: relative chromosome length
mydata$RelChromSize <- mydata$phys.map.length/mydata$MeanChromSize
```


```{r echo = FALSE}
model2 <- lm(linkage.map.length.correctedHW ~ phys.map.length, data = chromosome.stats)
coef2 <- model2$coefficients
summary(model2)
r.squaredLR(model2)

# LMER
lmer.model = lmer(linkage.map.length.correctedHW ~ phys.map.length + (phys.map.length|species), data = chromosome.stats)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```

```{r message=FALSE, warning=FALSE, echo=FALSE}
chromosome.stats$chrrelativesize = NA
# Compute chromosome relative size
for (i in 1:nrow(chromosome.stats)) {
  # species.metadata = read.table(paste(wd, "data-cleaned/species_metadata.csv", sep = ""), sep = ";", header= TRUE, stringsAsFactors = FALSE)
  # genomesize = species.metadata$genome_size[which(gsub("_", " ", species.metadata$species) == chromosome.stats$species[i])]
  # chromosome.stats$chrrelativesize[i] = chromosome.stats$phys.map.length[i]/sum(chromosome.stats$phys.map.length[which(chromosome.stats$species == chromosome.stats$species[i])], na.rm = TRUE)
    chromosome.stats$chrrelativesize[i] = chromosome.stats$phys.map.length[i]/mean(chromosome.stats$phys.map.length[which(chromosome.stats$species == chromosome.stats$species[i])], na.rm = TRUE)

}

# hist(chromosome.stats$chrrelativesize, breaks = 40, xlab = "Relative chromosome size",main ="")
```

```{r echo = FALSE}
#----------------------------------------------------------------------------
# Number of crossovers (linkage map length) ~ Chromosome relative size
#----------------------------------------------------------------------------
chromosome.stats$excessCO = chromosome.stats$linkage.map.length.correctedHW - 50
# Linear regression fit
mod = lm(excessCO ~ chrrelativesize, data = chromosome.stats)
summary(mod)
# LMER
lmer.model = lmer(excessCO ~ chrrelativesize + (chrrelativesize|species), data = chromosome.stats)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```

#### Figure 2

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 16, fig.align="center", fig.cap = "(ref:linkagemaplength-chrsize)"}
# Isolines
# A function that compute the isoline for a given GwRR
isoline = function(GwRR = 1, xend = 800, yend = 400) {
  x = xend
  y = xend*GwRR
  return(list(x = x, y = y))
}

lm.model = lm(linkage.map.length.correctedHW ~ phys.map.length, data = chromosome.stats)
coef = lm.model$coefficients
lmer.model = lmer((linkage.map.length.correctedHW) ~ phys.map.length + (phys.map.length|species), data = chromosome.stats)
rnd.coef = fixef(lmer.model)

G <- ggplot(data = chromosome.stats[idx.chr,], aes(x = phys.map.length, y = (linkage.map.length.correctedHW))) +
  geom_point(aes(color = species), pch = 19, size = dotsize) +
  geom_smooth(aes(color = species), method = "lm",se = F, size = linesize) +
  scale_fill_manual(values = color.species[idx.species]) +
  scale_color_manual(values = color.species[idx.species]) +
  geom_abline(intercept = coef[1], slope = coef[2], size = linesize) +
  # geom_abline(intercept = rnd.coef[1], slope = rnd.coef[2], size = 1, linetype = "dashed") +
  # geom_abline(intercept = fixef(lmer.model)[1], slope = fixef(lmer.model)[2], size = 1, linetype = "twodash", xlim = c(0, 800)) +
  xlab("Chromosome size (Mb)") + ylab("Linkage map length (cM)") +
  coord_cartesian(xlim = c(0, 800), ylim = c(0, 400), clip="off") +
  # ylim(0, 400) + xlim(0, 800) +
  geom_segment(aes(x = 0, y = rnd.coef[1], xend = 800, yend = rnd.coef[1] + 800*rnd.coef[2]), size = linesize, linetype = "twodash", xlim = c(0, 800), colour = "Black") +
  geom_segment(aes(x = 0, y = 0, xend = isoline(8)$x, yend = isoline(8)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(4)$x, yend = isoline(4)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(2)$x, yend = isoline(2)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(1)$x, yend = isoline(1)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.5)$x, yend = isoline(0.5)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.33)$x, yend = isoline(0.33)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.25)$x, yend = isoline(0.25)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.125)$x, yend = isoline(0.125)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')
# G

G1 <- ggplot(data = dataSpecies, aes(x = MeanChromSize, y = intercept1)) + geom_point() +
  scale_x_log10() +
    xlab("Mean chromosome size (Mb)") + ylab("Intercept") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# G1

G2 <- ggplot(data = dataSpecies, aes(x = MeanChromSize, y = slope1)) + geom_point() + 
  scale_x_log10() + scale_y_log10() +
  xlab("Mean chromosome size (Mb)") + ylab("Slope") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')

# Linear regression fit
mod = lm(excessCO ~ chrrelativesize, data = chromosome.stats)
# summary(mod)
# LMER
lmer.model = lmer(excessCO ~ chrrelativesize + (chrrelativesize|species), data = chromosome.stats)
summary(lmer.model)
G4 = ggplot(data = chromosome.stats[idx.chr,], aes(x = chrrelativesize, y = excessCO)) +
  geom_point(aes(fill = species), pch=21) +
  geom_smooth(aes(colour = species), method = "lm", se = FALSE) +
    scale_fill_manual(values = color.species[idx.species]) +
  scale_color_manual(values = color.species[idx.species]) +
  xlab("Relative chromosome size") + ylab("Excess of CO (cM)") +
  # geom_hline(aes(yintercept = 50), colour = "Red", linetype = "solid", size = 1.2) + # The expected regression line
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = 1) +
  geom_abline(intercept = fixef(lmer.model)[[1]], slope = fixef(lmer.model)[[2]], linetype = "twodash", size = 1) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')

ggpubr::ggarrange(G, ggarrange(G1, G2, nrow = 2, labels = c("B", "C")), G4, ncol = 3, labels = c("A", "", "D"), widths = c(2, 1, 3))
```

(ref:linkagemaplength-chrsize) (ref:linkagemaplength-chrsize) Relationship between linkage map length and chromosome length. (A) Correlation between chromosome length (Mb) and linkage map length (cM). Each point represents a chromosome (n=665). For clarity, we substracted 50cM to the linkage map length to remove the mandatory crossover and represent only the excess of crossovers. Species are presented in different colors (57 species). The linear regression is the solid black line. The fixed regression of the Linear Mixed Model is the dashed black line. Species random slopes are in colors. Isolines of the Genome-wide Recombination Rate (GwRR) were plotted in dotted red lines to represent regions of equal recombination rates. (B) Species random intercepts as a function of the specific mean chromosome size (Mb). (C) Species random slopes as a function of the specific mean chromosome size (Mb). (D) Within species effect of relative chromosome size on linkage map length. Each point represents a chromosome (n=665). Species are presented in different colors (57 species). Black solid line is the linear regression across species while dashed black line is the linear mixed regression with a species random effect. Colored solid lines represent the Linear Mixed Model regression line (LMER) fitted to the data, with random regressions fitted to species.


```{r message=FALSE, warning=FALSE, include=FALSE}
fontsize = 8
dotsize = 0.2
linesize = 0.4

# Isolines
# A function that compute the isoline for a given GwRR
isoline = function(GwRR = 1, xend = 800, yend = 400) {
  x = xend
  y = xend*GwRR
  return(list(x = x, y = y))
}

lm.model = lm(linkage.map.length.correctedHW ~ phys.map.length, data = chromosome.stats)
coef = lm.model$coefficients
lmer.model = lmer((linkage.map.length.correctedHW) ~ phys.map.length + (phys.map.length|species), data = chromosome.stats)
rnd.coef = fixef(lmer.model)

labels = data.frame(x = c(70,120,220,420,780,780,780,780), y = c(400, 400, 400, 400, 370, 240, 180, 80), lab = c("8", "4", "2", "1", "0.5", "0.33", "0.25", "0.125"))

G <- ggplot(data = chromosome.stats[idx.chr,], aes(x = phys.map.length, y = (linkage.map.length.correctedHW))) +
  geom_point(aes(color = species), alpha = 0.4, pch = 19, size = dotsize) +
  geom_smooth(aes(color = species), method = "lm",se = F, size = linesize) +
  scale_fill_manual(values = color.species[idx.species]) +
  scale_color_manual(values = color.species[idx.species]) +
  geom_abline(intercept = coef[1], slope = coef[2], size = linesize) +
  # geom_abline(intercept = rnd.coef[1], slope = rnd.coef[2], size = 1, linetype = "dashed") +
  # geom_abline(intercept = fixef(lmer.model)[1], slope = fixef(lmer.model)[2], size = 1, linetype = "twodash", xlim = c(0, 800)) +
  xlab("Chromosome size (Mb)") + ylab("Linkage map length (cM)") +
  coord_cartesian(xlim = c(0, 800), ylim = c(0, 400), clip="off") +
  # ylim(0, 400) + xlim(0, 800) +
  geom_segment(aes(x = 0, y = rnd.coef[1], xend = 800, yend = rnd.coef[1] + 800*rnd.coef[2]), size = linesize, linetype = "twodash", xlim = c(0, 800), colour = "Black") +
  geom_segment(aes(x = 0, y = 0, xend = isoline(8)$x, yend = isoline(8)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
geom_segment(aes(x = 0, y = 0, xend = isoline(4)$x, yend = isoline(4)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(2)$x, yend = isoline(2)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(1)$x, yend = isoline(1)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.5)$x, yend = isoline(0.5)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.33)$x, yend = isoline(0.33)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.25)$x, yend = isoline(0.25)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_segment(aes(x = 0, y = 0, xend = isoline(0.125)$x, yend = isoline(0.125)$y), colour = "Red", linetype = "dotted", size = linesize-0.2) +
  geom_text(data = labels, aes(x = x, y = y, label = lab), color = "Red", size = 3) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')
# G

# Linear regression fit
mod = lm(excessCO ~ chrrelativesize, data = chromosome.stats)
# summary(mod)
# LMER
lmer.model = lmer(excessCO ~ chrrelativesize + (chrrelativesize|species), data = chromosome.stats)
summary(lmer.model)
G4 = ggplot(data = chromosome.stats[idx.chr,], aes(x = chrrelativesize, y = excessCO)) +
  geom_point(aes(color = species), alpha = 0.4, pch=19, size = dotsize) +
  geom_smooth(aes(color = species), method = "lm", se = FALSE, size = linesize) +
  # scale_fill_manual(values = color.species[idx.species]) +
  scale_color_manual(values = color.species[idx.species]) +
  xlab("Relative chromosome size") + ylab("Excess of CO (cM)") +
  # geom_hline(aes(yintercept = 50), colour = "Red", linetype = "solid", size = 1.2) + # The expected regression line
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = linesize) +
  geom_abline(intercept = fixef(lmer.model)[[1]], slope = fixef(lmer.model)[[2]], linetype = "twodash", size = linesize) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')

tiffPlot = ggpubr::ggarrange(G, G4, ncol = 2, labels = c("A", "B"), widths = c(3, 2), font.label = list(size = 9)) +
  theme(plot.margin = margin(0,0,0,0, "cm"))
ggsave(file = paste(wd, "figures/article_one/Fig2.tiff", sep = ""), plot = tiffPlot, width = 7, height = 3, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig2.jpeg", sep = ""), plot = tiffPlot, width = 7, height = 3, dpi = 300)
```


#### Figure S4

```{r message=FALSE, warning=FALSE, include=FALSE}
fontsize = 10
dotsize = 0.6
linesize = 0.6

# Isolines
# A function that compute the isoline for a given GwRR
isoline = function(GwRR = 1, xend = 800, yend = 400) {
  x = xend
  y = xend*GwRR
  return(list(x = x, y = y))
}

lm.model = lm(linkage.map.length.correctedHW ~ phys.map.length, data = chromosome.stats)
coef = lm.model$coefficients
lmer.model = lmer((linkage.map.length.correctedHW) ~ phys.map.length + (phys.map.length|species), data = chromosome.stats)
rnd.coef = fixef(lmer.model)

G1 <- ggplot(data = dataSpecies, aes(x = MeanChromSize, y = intercept1)) +   geom_point(size = dotsize) +
  scale_x_log10() +
    xlab("Chromosome size (Mb)") + ylab("Intercept") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')
# G1

G2 <- ggplot(data = dataSpecies, aes(x = MeanChromSize, y = slope1)) + geom_point(size = dotsize) + 
  scale_x_log10() + scale_y_log10() +
  xlab("Chromosome size (Mb)") + ylab("Slope") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')


tiffPlot = ggpubr::ggarrange(G1, G2, nrow = 2, labels = c("A", "B"), font.label = list(size = 9)) +
  theme(plot.margin = margin(0,0,0,0, "cm"))
ggsave(file = paste(wd, "figures/article_one/FigS4.tiff", sep = ""), plot = G2, width = 4, height = 4, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS4.jpeg", sep = ""), plot = G2, width = 4, height = 4, dpi = 300)
```




Yet, it is difficult to imagine a biological mechanism that is able to consider relative sizes instead of absolute sizes. Given that number of genes are roughly constant across species and assuming that genes are distributed proportionnally to relative chromosome sizes within species, we can imagine that number of genes of a chromosome could be a good proxy of the relative size of the chromosome.

Yet, number of genes is not constant across species in our dataset, as expected if annotations are not standard and if some overlapping genes/alternative variants increases the number of gene copies. Besides, we have unequal sampling across species and for some species, we have missing chromosomes.

Hence we decided to divide gene count by the mean gene count of the species (i.e. a relative gene count) as a good proxy of relative chromosome size and compared with standardizing by the total gene count (despite uneven sampling.

Finally we kept the standardization by the total gene count.


```{r echo = FALSE}
nb_chromosomes = aggregate(genecount ~ species, data = chromosome.stats, FUN = function(x){length(x)})

nbgenes = aggregate(genecount ~ species, data = chromosome.stats, FUN = function(x){mean(x, na.rm = TRUE)})

nbgenes_total = aggregate(genecount ~ species, data = chromosome.stats, FUN = function(x){sum(x, na.rm = TRUE)})

nbgenes = merge(nb_chromosomes, nbgenes, by = "species")
nbgenes = merge(nbgenes, nbgenes_total, by = "species")

colnames(nbgenes) = c("species", "n_chromosome", "mean_genecount", "total_genecount")

kable(nbgenes, col.names = c("Species", "Number of chromosomes", "Mean gene count", "Total number of genes"), caption = "Gene count per species", align = "c", digits = 0)
```


```{r echo = FALSE}
chromosome.stats$genecount_std = NA
for (i in 1:nrow(chromosome.stats)) {
  if (!is.na(chromosome.stats$genecount[i])) {
      chromosome.stats$genecount_std[i] = chromosome.stats$genecount[i]/nbgenes$total_genecount[which(nbgenes$species == chromosome.stats$species[i])]
  }
}
```


```{r echo = FALSE}
#----------------------------------------------------------------------------
# Number of crossovers (linkage map length) ~ Number of genes
#----------------------------------------------------------------------------
# Linear regression fit
mod = lm(excessCO ~ genecount_std, data = chromosome.stats)
summary(mod)
# LMER
lmer.model = lmer(excessCO ~ genecount_std + (1|species), data = chromosome.stats)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:linkagemaplength-genecount)"}
p = ggplot(data = chromosome.stats, aes(x = genecount_std, y = excessCO)) +
  geom_point(aes(fill = species), pch = 21) +
  xlab("Relative gene count") + ylab("Excess of CO (cM)") +
  geom_smooth(aes(colour = species), method = "lm", se = F) +
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = 1.2) +
  geom_abline(intercept = fixef(lmer.model)[1], slope = fixef(lmer.model)[2], linetype = "twodash", size = 1.2) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
p
```

(ref:linkagemaplength-genecount) (ref:linkagemaplength-genecount) Relationship between linkage map length and relative number of genes. Each point represents a chromosome (n=515). Species are presented in different colors (42 species). Black solid line is the linear regression across species while dashed black line is the linear mixed regression with a species random effect. Colored solid lines represent the Linear Mixed Model regression line (LMER) fitted to the data, with random regressions fitted to species.





## A model explaining variation in linkage map length by chromosome relative size

<!-- Genetic-map_{i,j} - 50 = b_i x Physi_map_{i,j} / GenomeSize_i -->
<!-- oÃ¹ b_i est le facteur dâinterfÃ©rence espÃ¨ce spÃ©cifique. -->
<!-- mydata$RelChromSize <- mydata$phys.map.length/mydata$GenomeSize -->
<!-- lmer( (mydata$linkage.map.length - 50) ~ 0 + mydata$RelChromSize|mydata$set ) -->
<!-- Le R2 est de 0.95 -->
<!-- Si on rajoute un intercept random Ã§a nâamÃ©liore quasiment pas -->
<!-- lmer( (mydata$linkage.map.length-50) ~ 1|mydata$set + mydata$RelChromSize|mydata$set ) -->
<!-- R2 = 0.962 -->


Ultimately, we can think of a model:

$$ d = 50 + a*n_i $$
$$ d = 50 + a*n*\frac{L_i}{L} $$
Where $n$ is the number of genes of the species, $n_i$ the number of genes in chromosome $i$, $L$ the total physical length of the genome and $L_i$ the physical length of chromosome $i$, and, finally, $a$  is a coefficient supposedly constant across species.

<!-- A species has N chromosomes of length Li (i from 1 to N). We assume that the number of genes is proportional to gene length: -->
<!-- So ni = n x Li / L where L is the total genome size and n is the toal number of genes. -->
<!-- If we assume that the excess of genetic distance, beyond the obligate 50 cM, is proportional to the number of genes, not the physical length, the genetic distance is given by: -->
<!-- di = 50 + a x ni -->
<!-- di = 50 + a x n x Li / L  -->
<!-- If we assume that the number of genes, n, and the a coefficient are constant across species we have the following schematic predictions: -->







# Intra-chromosomal heterogeneity in recombination

We observed contrasted patterns between species.

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 8, fig.width = 15, fig.align="center", fig.cap = "(ref:heterogeneity-recombination-maps)"}
# Import data for the selected species
# Plot one chromosome per species with a centromere position,
# but add a pale ribbon of all pooled chromosomes for each species (similarity of recombination landscapes within species)

set = c("Arabidopsis_thaliana_Serin2017",
        "Capsella_rubella_Slotte2013",
        "Eucalyptus_grandis_Bertholome2015",
        "Malus_domestica_DiPierro2016",
        "Nelumbo_nucifera_Gui2018",
        "Zea_mays_MaizeGDBConsensus_v4")
chromosome = as.character(c(1,1,2,10,3,10))       

recombination_maps = data.frame(phys = numeric(), rec.rate = numeric(), upper = numeric(), lower = numeric(), relative_position = numeric(), set = character(), species = character(), chromosome = character())

# Add all chromosomes for each species
df = chromosome.stats[which(chromosome.stats$set %in% set),c(1,2,24)]
for (s in 1:nrow(df)) {
  import_tmp = read.table(paste(wd, "/output/recombination_maps/loess/100kbwind/", df$set[s], "_chromosome", df$chromosome[s], ".txt", sep = ""), header = TRUE, sep ="\t")
  import_tmp$relative_position = import_tmp$phys/max(import_tmp$phys, na.rm = TRUE)
  import_tmp$set = df$set[s]
  import_tmp$species = gsub("_", " ", metadata.clean$species[which(metadata.clean$id == df$set[s])])
  import_tmp$chromosome = df$chromosome[s]
  recombination_maps = rbind(recombination_maps, import_tmp)
  rm(import_tmp)
}
rm(df)

recombination_maps = recombination_maps[!is.na(recombination_maps$phys),]
recombination_maps = recombination_maps[!is.na(recombination_maps$rec.rate),]

# Order species in legend by mean chromosome size
species.names = c("Arabidopsis thaliana", "Capsella rubella", "Eucalyptus grandis", "Malus domestica", "Nelumbo nucifera", "Zea mays")
meanchrsize = aggregate(phys.map.length ~ species, chromosome.stats, mean)
meanchrsize = subset(meanchrsize, meanchrsize$species %in% species.names)
# meanchrsize = meanchrsize[order(meanchrsize$phys.map.length),]
meanchrsize$species = as.factor(meanchrsize$species)
# meanchrsize$species = factor(meanchrsize$species, levels = meanchrsize$species)

recombination_maps$species = factor(recombination_maps$species, levels = meanchrsize$species[order(meanchrsize$phys.map.length)])
# levels(recombination_maps$species)
# levels(meanchrsize$species)

# Subset only one chromosome per species and compute a C.I. for all pooled chromosomes (the species pattern)
df_subset = recombination_maps[which(paste(recombination_maps$set, recombination_maps$chromosome) %in% paste(set, chromosome)),]
  
# Add a dot on centromere position (i.e. centromeric index)
# The window exactly after the centromeric index
# CI = chromosome.stats$centromeric_index_position_oriented[which(paste(chromosome.stats$set, chromosome.stats$chromosome) %in% paste(set, chromosome))]/chromosome.stats$phys.map.length[which(paste(chromosome.stats$set, chromosome.stats$chromosome) %in% paste(set, chromosome))]
CI = chromosome.stats$centromeric_index[which(paste(chromosome.stats$set, chromosome.stats$chromosome) %in% paste(set, chromosome))]
# Manually correct the position of the centromere (p or 1-p), according to the orientation of the chromosome
CI[c(2,3,5)] = (1 - CI[c(2,3,5)])
# CI
# Retrieve the position on the recombination landscape (i.e. the x and y coordinates)
for (i in 1:nrow(meanchrsize)) {
  tmp = df_subset[which(paste(df_subset$set, df_subset$chromosome) == paste(set[i], chromosome[i])),]
  # The first position on the map for which phys > x
  # Adjust the x position
  meanchrsize$x[i] = sort(tmp$relative_position[tmp$relative_position > CI[i]])[1]
  meanchrsize$y[i] = tmp$rec.rate[which(tmp$relative_position == meanchrsize$x[i])]
  rm(tmp)
}
# rm(CI)

# Good espacement between hues and color-blind palettes
# colors = cividis(n = nrow(meanchrsize))
colors = brewer.pal(n = nrow(meanchrsize), name = "Dark2")

# Estimate the ribbon interval
# ymin and ymax for each relative position in 100 bins
ribbon = data.frame(set = rep(set, each = 100), species = NA, start = rep(seq(0, 1, length.out = 101)[1:100], times = length(set)), end = rep(seq(0, 1, length.out = 101)[2:101], times = length(set)),y = NA, ymin = NA, ymax = NA)
ribbon$x = (ribbon$start + ribbon$end)/2
# Estimate ymin and ymax
for (i in 1:nrow(ribbon)) {
  ribbon$species[i] = unique(as.character(df_subset$species[which(df_subset$set == ribbon$set[i])]))
    ribbon$y[i] = mean(recombination_maps$rec.rate[which(recombination_maps$relative_position > ribbon$start[i] & recombination_maps$relative_position < ribbon$end[i] & recombination_maps$set == ribbon$set[i])], na.rm = FALSE)
    ribbon$ymin[i] = min(recombination_maps$rec.rate[which(recombination_maps$relative_position > ribbon$start[i] & recombination_maps$relative_position < ribbon$end[i] & recombination_maps$set == ribbon$set[i])], na.rm = FALSE)
  ribbon$ymax[i] = max(recombination_maps$rec.rate[which(recombination_maps$relative_position > ribbon$start[i] & recombination_maps$relative_position < ribbon$end[i] & recombination_maps$set == ribbon$set[i])], na.rm = FALSE)
}
ribbon$ymin[which(ribbon$ymin == Inf)] = NA
ribbon$ymax[which(ribbon$ymax == -Inf)] = NA

meanchrsize$species = as.character(meanchrsize$species)

landscape_capsella = ggplot(data = ribbon[which(ribbon$species == "Capsella rubella"),], aes(x = x, y = y)) +
  geom_line(data = df_subset[which(df_subset$species == "Capsella rubella"),], aes(x = relative_position, y = rec.rate), color = colors[1], size = 1.6) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Capsella rubella"),], aes(x = x, y = y), color = colors[1], size = 12) +
  geom_line(colour = colors[1], size = 1.4, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[1], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')



landscape_arabidopsis = ggplot(data = ribbon[which(ribbon$species == "Arabidopsis thaliana"),], aes(x = x, y = y)) +
  geom_line(data = df_subset[which(df_subset$species == "Arabidopsis thaliana"),], aes(x = relative_position, y = rec.rate), color = colors[2], size = 1.6) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Arabidopsis thaliana"),], aes(x = x, y = y), color = colors[2], size = 12) +
  geom_line(colour = colors[2], size = 1.4, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[2], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')
# landscape_arabidopsis

landscape_malus = ggplot(data = ribbon[which(ribbon$species == "Malus domestica"),], aes(x = x, y = y)) +
  geom_line(data = df_subset[which(df_subset$species == "Malus domestica"),], aes(x = relative_position, y = rec.rate), color = colors[3], size = 1.6) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Malus domestica"),], aes(x = x, y = y), color = colors[3], size = 12) +
  geom_line(colour = colors[3], size = 1.4, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[3], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')

landscape_eucalyptus = ggplot(data = ribbon[which(ribbon$species == "Eucalyptus grandis"),], aes(x = x, y = y)) +
  geom_line(data = df_subset[which(df_subset$species == "Eucalyptus grandis"),], aes(x = relative_position, y = rec.rate), color = colors[4], size = 1.6) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Eucalyptus grandis"),], aes(x = x, y = y), color = colors[4], size = 12) +
  geom_line(colour = colors[4], size = 1.4, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[4], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')


landscape_nelumbo = ggplot(data = ribbon[which(ribbon$species == "Nelumbo nucifera"),], aes(x = x, y = y)) +
  geom_line(data = df_subset[which(df_subset$species == "Nelumbo nucifera"),], aes(x = relative_position, y = rec.rate), color = colors[5], size = 1.6) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Nelumbo nucifera"),], aes(x = x, y = y), color = colors[5], size = 12) +
  geom_line(colour = colors[5], size = 1.4, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[5], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')
# landscape_nelumbo


landscape_zea = ggplot(data = ribbon[which(ribbon$species == "Zea mays"),], aes(x = x, y = y)) +
  geom_line(data = df_subset[which(df_subset$species == "Zea mays"),], aes(x = relative_position, y = rec.rate), color = colors[6], size = 1.6) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Zea mays"),], aes(x = x, y = y), color = colors[6], size = 12) +
  geom_line(colour = colors[6], size = 1.4, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[6], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')
# landscape_zea

ggpubr::ggarrange(landscape_capsella, landscape_arabidopsis,
                  landscape_malus, landscape_eucalyptus,
                  landscape_nelumbo, landscape_zea, ncol = 3, nrow = 2, labels = c("A", "B", "C", "D", "E", "F"))
```

(ref:heterogeneity-recombination-maps) (ref:heterogeneity-recombination-maps) The diversity of recombination landscapes in angiosperms demonstrated in six different species. Recombination landscapes are similar within species (pooled chromosomes). Physical distances were scaled for comparison of chromosomes with different sizes. Estimates of recombination rates were obtained by 1,000 bootstraps of loci in windows of 100kb with loess regression and automatic span calibration. The mean species landscape (dashed line) was estimated by computing the mean recombination rate in 100 bins along the chromosome axis, all chromosomes pooled. Similarly, the lower and upper boundaries (pale ribbon) were estimated by taking the minimum and maximum recombination rates in 100 bins. One chromosome is represented in a solid line for each species, with the physical position of the centromere pointed by a dot. Species ordered by ascending mean chromosome size. (A) *Capsella rubella* chromosome 1 and n = 7 chromosomes pooled (B) *Arabidopsis thaliana* chromosome 1 and n = 5 chromosomes pooled (C) *Malus domestica* chromosome 2 and n = 17 chromosomes pooled (D) *Eucalyptus grandis* chromosome 10  and n = 11 chromosomes pooled (E) *Nelumbo nucifera* chromosome 3 and n = 8 chromosomes pooled (F) *Zea mays* chromosome 10 and n = 10 chromosomes pooled.


#### Figure 3

```{r message=FALSE, warning=FALSE, include=FALSE}
fontsize = 8
dotsize = 4
linesize = 0.4

# Import data for the selected species
# Plot one chromosome per species with a centromere position,
# but add a pale ribbon of all pooled chromosomes for each species (similarity of recombination landscapes within species)

set = c("Arabidopsis_thaliana_Serin2017",
        "Capsella_rubella_Slotte2013",
        "Eucalyptus_grandis_Bertholome2015",
        "Malus_domestica_DiPierro2016",
        "Nelumbo_nucifera_Gui2018",
        "Zea_mays_MaizeGDBConsensus_v4")
chromosome = as.character(c(1,1,2,10,3,10))       

recombination_maps = data.frame(phys = numeric(), rec.rate = numeric(), upper = numeric(), lower = numeric(), relative_position = numeric(), set = character(), species = character(), chromosome = character())

# Add all chromosomes for each species
df = chromosome.stats[which(chromosome.stats$set %in% set),c(1,2,24)]
for (s in 1:nrow(df)) {
  import_tmp = read.table(paste(wd, "/output/recombination_maps/loess/100kbwind/", df$set[s], "_chromosome", df$chromosome[s], ".txt", sep = ""), header = TRUE, sep ="\t")
  import_tmp$relative_position = import_tmp$phys/max(import_tmp$phys, na.rm = TRUE)
  import_tmp$set = df$set[s]
  import_tmp$species = gsub("_", " ", metadata.clean$species[which(metadata.clean$id == df$set[s])])
  import_tmp$chromosome = df$chromosome[s]
  recombination_maps = rbind(recombination_maps, import_tmp)
  rm(import_tmp)
}
rm(df)

recombination_maps = recombination_maps[!is.na(recombination_maps$phys),]
recombination_maps = recombination_maps[!is.na(recombination_maps$rec.rate),]

# Order species in legend by mean chromosome size
species.names = c("Arabidopsis thaliana", "Capsella rubella", "Eucalyptus grandis", "Malus domestica", "Nelumbo nucifera", "Zea mays")
meanchrsize = aggregate(phys.map.length ~ species, chromosome.stats, mean)
meanchrsize = subset(meanchrsize, meanchrsize$species %in% species.names)
# meanchrsize = meanchrsize[order(meanchrsize$phys.map.length),]
meanchrsize$species = as.factor(meanchrsize$species)
# meanchrsize$species = factor(meanchrsize$species, levels = meanchrsize$species)

recombination_maps$species = factor(recombination_maps$species, levels = meanchrsize$species[order(meanchrsize$phys.map.length)])
# levels(recombination_maps$species)
# levels(meanchrsize$species)

# Subset only one chromosome per species and compute a C.I. for all pooled chromosomes (the species pattern)
df_subset = recombination_maps[which(paste(recombination_maps$set, recombination_maps$chromosome) %in% paste(set, chromosome)),]
  
# Add a dot on centromere position (i.e. centromeric index)
# The window exactly after the centromeric index
# CI = chromosome.stats$centromeric_index_position_oriented[which(paste(chromosome.stats$set, chromosome.stats$chromosome) %in% paste(set, chromosome))]/chromosome.stats$phys.map.length[which(paste(chromosome.stats$set, chromosome.stats$chromosome) %in% paste(set, chromosome))]
CI = chromosome.stats$centromeric_index[which(paste(chromosome.stats$set, chromosome.stats$chromosome) %in% paste(set, chromosome))]
# Manually correct the position of the centromere (p or 1-p), according to the orientation of the chromosome
CI[c(2,3,5)] = (1 - CI[c(2,3,5)])
# CI
# Retrieve the position on the recombination landscape (i.e. the x and y coordinates)
for (i in 1:nrow(meanchrsize)) {
  tmp = df_subset[which(paste(df_subset$set, df_subset$chromosome) == paste(set[i], chromosome[i])),]
  # The first position on the map for which phys > x
  # Adjust the x position
  meanchrsize$x[i] = sort(tmp$relative_position[tmp$relative_position > CI[i]])[1]
  meanchrsize$y[i] = tmp$rec.rate[which(tmp$relative_position == meanchrsize$x[i])]
  rm(tmp)
}
# rm(CI)

# Good espacement between hues and color-blind palettes
# colors = cividis(n = nrow(meanchrsize))
colors = brewer.pal(n = nrow(meanchrsize), name = "Dark2")

# Estimate the ribbon interval
# ymin and ymax for each relative position in 100 bins
ribbon = data.frame(set = rep(set, each = 100), species = NA, start = rep(seq(0, 1, length.out = 101)[1:100], times = length(set)), end = rep(seq(0, 1, length.out = 101)[2:101], times = length(set)),y = NA, ymin = NA, ymax = NA)
ribbon$x = (ribbon$start + ribbon$end)/2
# Estimate ymin and ymax
for (i in 1:nrow(ribbon)) {
  ribbon$species[i] = unique(as.character(df_subset$species[which(df_subset$set == ribbon$set[i])]))
    ribbon$y[i] = mean(recombination_maps$rec.rate[which(recombination_maps$relative_position > ribbon$start[i] & recombination_maps$relative_position < ribbon$end[i] & recombination_maps$set == ribbon$set[i])], na.rm = FALSE)
    ribbon$ymin[i] = min(recombination_maps$rec.rate[which(recombination_maps$relative_position > ribbon$start[i] & recombination_maps$relative_position < ribbon$end[i] & recombination_maps$set == ribbon$set[i])], na.rm = FALSE)
  ribbon$ymax[i] = max(recombination_maps$rec.rate[which(recombination_maps$relative_position > ribbon$start[i] & recombination_maps$relative_position < ribbon$end[i] & recombination_maps$set == ribbon$set[i])], na.rm = FALSE)
}
ribbon$ymin[which(ribbon$ymin == Inf)] = NA
ribbon$ymax[which(ribbon$ymax == -Inf)] = NA

meanchrsize$species = as.character(meanchrsize$species)



landscape_capsella = ggplot(data = ribbon[which(ribbon$species == "Capsella rubella"),], aes(x = x, y = y)) +
  ggtitle(paste("*Capsella rubella* chrom. 1<br>mean chrom. size = ", round(meanchrsize$phys.map.length[which(meanchrsize$species == "Capsella rubella")], digits = 0), " Mb", sep = "")) +
  geom_line(data = df_subset[which(df_subset$species == "Capsella rubella"),], aes(x = relative_position, y = rec.rate), color = colors[1], size = linesize) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Capsella rubella"),], aes(x = x, y = y), color = colors[1], size = dotsize) +
  # geom_line(colour = colors[1], size = linesize, linetype = "dashed") +
  geom_line(data = ribbon[which(ribbon$species == "Capsella rubella"),], aes(x = x, y = y), colour = colors[1], size = linesize, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[1], alpha = 0.2) +
  xlab("") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = ggtext::element_markdown(color="black", size=fontsize, face="plain",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')



landscape_arabidopsis = ggplot(data = ribbon[which(ribbon$species == "Arabidopsis thaliana"),], aes(x = x, y = y)) +
      ggtitle(paste("*Arabidopsis thaliana* chrom. 1<br>mean chrom. size = ", round(meanchrsize$phys.map.length[which(meanchrsize$species == "Arabidopsis thaliana")], digits = 0), " Mb", sep = "")) +
  geom_line(data = df_subset[which(df_subset$species == "Arabidopsis thaliana"),], aes(x = relative_position, y = rec.rate), color = colors[2], size = linesize) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Arabidopsis thaliana"),], aes(x = x, y = y), color = colors[2], size = dotsize) +
  geom_line(colour = colors[2], size = linesize, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[2], alpha = 0.2) +
  xlab("") + ylab("") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = ggtext::element_markdown(color="black", size=fontsize, face="plain",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')
# landscape_arabidopsis

landscape_malus = ggplot(data = ribbon[which(ribbon$species == "Malus domestica"),], aes(x = x, y = y)) +
  ggtitle(paste("*Malus domestica* chrom. 2<br>mean chrom. size = ", round(meanchrsize$phys.map.length[which(meanchrsize$species == "Malus domestica")], digits = 0), " Mb", sep = "")) +
  geom_line(data = df_subset[which(df_subset$species == "Malus domestica"),], aes(x = relative_position, y = rec.rate), color = colors[3], size = linesize) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Malus domestica"),], aes(x = x, y = y), color = colors[3], size = dotsize) +
  geom_line(colour = colors[3], size = linesize, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[3], alpha = 0.2) +
  xlab("") + ylab("") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = ggtext::element_markdown(color="black", size=fontsize, face="plain",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')

landscape_eucalyptus = ggplot(data = ribbon[which(ribbon$species == "Eucalyptus grandis"),], aes(x = x, y = y)) +
    ggtitle(paste("*Eucalyptus grandis* chrom. 10<br>mean chrom. size = ", round(meanchrsize$phys.map.length[which(meanchrsize$species == "Eucalyptus grandis")], digits = 0), " Mb", sep = "")) +
  geom_line(data = df_subset[which(df_subset$species == "Eucalyptus grandis"),], aes(x = relative_position, y = rec.rate), color = colors[4], size = linesize) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Eucalyptus grandis"),], aes(x = x, y = y), color = colors[4], size = dotsize) +
  geom_line(colour = colors[4], size = linesize, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[4], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("Recombination rate (cM/Mb)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = ggtext::element_markdown(color="black", size=fontsize, face="plain",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')


landscape_nelumbo = ggplot(data = ribbon[which(ribbon$species == "Nelumbo nucifera"),], aes(x = x, y = y)) +
  ggtitle(paste("*Nelumbo nucifera* chrom. 3 <br>mean chrom. size = ", round(meanchrsize$phys.map.length[which(meanchrsize$species == "Nelumbo nucifera")], digits = 0), " Mb", sep = "")) +
  geom_line(data = df_subset[which(df_subset$species == "Nelumbo nucifera"),], aes(x = relative_position, y = rec.rate), color = colors[5], size = linesize) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Nelumbo nucifera"),], aes(x = x, y = y), color = colors[5], size = dotsize) +
  geom_line(colour = colors[5], size = linesize, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[5], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = ggtext::element_markdown(color="black", size=fontsize, face="plain",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')
# landscape_nelumbo


landscape_zea = ggplot(data = ribbon[which(ribbon$species == "Zea mays"),], aes(x = x, y = y)) +
  ggtitle(paste("*Zea mays* chrom. 10<br>mean chrom. size = ", round(meanchrsize$phys.map.length[which(meanchrsize$species == "Zea mays")], digits = 0), " Mb", sep = "")) +
  geom_line(data = df_subset[which(df_subset$species == "Zea mays"),], aes(x = relative_position, y = rec.rate), color = colors[6], size = linesize) +
  geom_point(data = meanchrsize[which(meanchrsize$species == "Zea mays"),], aes(x = x, y = y), color = colors[6], size = dotsize) +
  geom_line(colour = colors[6], size = linesize, linetype = "dashed") +
  geom_ribbon(aes(x = x, ymin = ymin, ymax = ymax, fill = species), fill = colors[6], alpha = 0.2) +
  xlab("Relative genomic position") + ylab("") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = ggtext::element_markdown(color="black", size=fontsize, face="plain",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')
# landscape_zea

tiffPlot = ggpubr::ggarrange(landscape_capsella, landscape_arabidopsis,
                  landscape_malus, landscape_eucalyptus,
                  landscape_nelumbo, landscape_zea, ncol = 3, nrow = 2, labels = "", font.label = list(size = 9), vjust = 0.3) +
  theme(plot.margin = margin(0.3,0,0,0, "cm"))

ggsave(file = paste(wd, "figures/article_one/Fig3.tiff", sep = ""), plot = tiffPlot, width = 6.5, height = 3.5, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig3.jpeg", sep = ""), plot = tiffPlot, width = 6.5, height = 3.5, dpi = 300)
```



```{r echo = FALSE}
chromosome.stats$brokenstick_pvariance_scaled = scale(log10(chromosome.stats$brokenstick_pvariance))

# Correlation coefficient per species
species.stats = aggregate(chromosome ~ species, data = chromosome.stats, FUN = function(x){length(x)})
colnames(species.stats)[2] = "chromosome_number"

# Adding chromosome length & mean periphery-bias ratio
chr_size = aggregate(phys.map.length ~ species, data = chromosome.stats, FUN = function(x){mean(x, na.rm = TRUE)})
species.stats = merge(species.stats, chr_size)
peripherybias = aggregate(peripherybias_ratio ~ species, data = chromosome.stats, FUN = function(x){mean(x, na.rm = TRUE)})
species.stats = merge(species.stats, peripherybias)

# Adding heterogeneity measures
cvrecrate = aggregate(cv.recrate ~ species, data = chromosome.stats, FUN = function(x){mean(x, na.rm = TRUE)})
species.stats = merge(species.stats, cvrecrate)
pvariance = aggregate(brokenstick_pvariance_scaled ~ species, data = chromosome.stats, FUN = function(x){mean(x, na.rm = TRUE)})
colnames(pvariance)[2] = "pvariance" 
species.stats = merge(species.stats, pvariance)

# Remove species with less than 5 chromosomes
# species.stats = subset(species.stats, species.stats$chromosome_number > 5)
```



## Broken stick model

We used the broken stick model (k = 10) to visually describe the diversity of patterns.


```{r message=FALSE, warning=FALSE, echo=FALSE}
#============================================================================
# Figures. Broken stick barplot solo
#============================================================================
# load(file = paste(wd, "output/brokenstick/brokenstick10.Rda", sep = ""))
load(file = paste(wd, "output/brokenstick/brokenstick10_v2.Rda", sep = ""))

brokenstick$chr.size.Mb = NA
for (i in 1:nrow(brokenstick)) {
  brokenstick$chr.size.Mb[i] = chromosome.stats$phys.map.length[which(paste0(chromosome.stats$set, "_", chromosome.stats$chromosome) == brokenstick$sample[i])]
}

# brokenspecies = brokenstick[,c(2,5)]
# brokenspecies$set = as.character(brokenspecies$set)
# brokenspecies = aggregate(brokenspecies, by = list(brokenspecies$set), sd)
# brokenspecies = brokenspecies[,-c(2)]
# colnames(brokenspecies) = c("set", "var.proportion")
# # Order by ascending variance in proportions
# brokenspecies = brokenspecies[order(brokenspecies$var.proportion),]

# Order by mean genome size
brokenspecies = brokenstick[,c(2,8)]
brokenspecies$set = as.character(brokenspecies$set)
brokenspecies = aggregate(brokenspecies, by = list(brokenspecies$set), mean)
brokenspecies = brokenspecies[,-c(2)]
colnames(brokenspecies) = c("set", "mean.chr.size")
brokenspecies = brokenspecies[order(brokenspecies$mean.chr.size),]


# Reorder groups
brokenstick$set = as.factor(brokenstick$set)
brokenstick$set = factor(brokenstick$set, levels = brokenspecies$set)

# Add the centromere position (oriented centromeric index)
# Centromere position on the broken stick is the relative physical distance  corresponding to the physical position of the Centromeric Index
# x = sample, y = C.I.
# Get Centromeric Index of the chromosome
centromere_brokenstick = unique(brokenstick[,1:3])
# Get the relative physical position
centromere_brokenstick$CI = NA
for (i in 1:nrow(centromere_brokenstick)) {
  CI = chromosome.stats$centromeric_index_position_oriented[which(chromosome.stats$species == as.character(centromere_brokenstick$set[i]) & chromosome.stats$chromosome == centromere_brokenstick$chromosome[i])]
  totalchrsize = chromosome.stats$phys.map.length[which(chromosome.stats$species == as.character(centromere_brokenstick$set[i]) & chromosome.stats$chromosome == centromere_brokenstick$chromosome[i])]
  if (!is.na(CI)) {
      if (CI/totalchrsize <= 0) {
        centromere_brokenstick$CI[i] = NA
      } else {
        centromere_brokenstick$CI[i] = CI/totalchrsize
    }
  }
}

brokenstick = merge(brokenstick, centromere_brokenstick[,c(1,4)], by = "sample", no.dups = TRUE)

# Orient chromosomes
# When information exists, orient the chromosome with the longer arm on top
for (i in 1:nrow(centromere_brokenstick)) {
  if (!is.na(centromere_brokenstick$CI[i])) {
    # Invert segments only if CI > 0.5, i.e. longer arm on bottom
    if (centromere_brokenstick$CI[i] > 0.5) {
      brokenstick$CI[which(brokenstick$sample == centromere_brokenstick$sample[i])] = 1 - centromere_brokenstick$CI[i]
      # KISS
      brokenstick$segment[c(which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p1"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p2"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p3"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p4"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p5"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p6"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p7"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p8"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p9"),
                            which(brokenstick$sample == centromere_brokenstick$sample[i] & brokenstick$segment == "p10"))] = c("p10", "p9", "p8", "p7", "p6", "p5", "p4", "p3", "p2", "p1")
    }
  }
}

brokenstick$CI[which(brokenstick$CI <= 0)] = NA
```


```{r echo = FALSE}
# Classify species in three categories:
# peak at 0, strictly in the telomere, i.e. telomere pattern
# peak outside the telomere, around 0.1-0.2, i.e. sub-telomere pattern
# exception, species following a unique pattern
telomere_pattern = data.frame(set = unique(brokenstick$set), pattern = NA)
pattern_telomere = c("Aegilops speltoides", "Arachis duranensis", "Arachis hypogaea",
                     "Brachypodium distachyon", "Brassica napus", "Camelina sativa", "Capsicum annuum", "Cenchrus americanus",
                     "Citrullus lanatus", "Citrus sinensis", "Coffea canephora", "Cucumis melo",
                     "Dioscorea alata", "Glycine max", "Gossypium hirsutum", "Gossypium raimondii",
                     "Helianthus annuus", "Hordeum vulgare", "Lupinus albus", "Lupinus angustifolius",
                     "Oryza nivara", "Oryza sativa", "Phaseolus vulgaris", "Prunus mume", "Setaria italica",
                     "Solanum lycopersicum", "Solanum tuberosum", "Theobroma cacao", "Triticum aestivum",
                     "Triticum dicoccoides", "Triticum urartu", "Vigna unguiculata", "Vitis vinifera",
                     "Zea mays")
pattern_peak = c("Boechera stricta", "Brassica rapa", "Cucumis sativus", "Cucurbita maxima", "Cucurbita pepo", "Draba nivalis",
                 "Elaeis guineensis", "Juglans regia", "Malus domestica", "Mangifera indica", "Manihot esculenta",
                 "Momordica charantia", "Panicum hallii", "Prunus persica", "Sesamum indicum", "Sorghum bicolor")
pattern_exception = c("Arabidopsis thaliana", "Camellia sinensis", "Quercus sp", "Raphanus sativus", "Capsella rubella", "Eucalyptus grandis", "Nelumbo nucifera")

telomere_pattern$pattern[which(telomere_pattern$set %in% pattern_telomere)] = "telomere"
telomere_pattern$pattern[which(telomere_pattern$set %in% pattern_peak)] = "peak"
telomere_pattern$pattern[which(telomere_pattern$set %in% pattern_exception)] = "exception"

telomere_pattern$pattern = as.factor(telomere_pattern$pattern)
```



```{r message=FALSE, warning=FALSE, echo=FALSE}
# New names for facets (add mean chromosome size)
chrsize = numeric(length(levels(brokenstick$set)))
for (i in 1:length(chrsize)) {
  chrsize[i] = mean(chromosome.stats$phys.map.length[which(chromosome.stats$species == levels(brokenstick$set)[i])], na.rm = TRUE)
}

brokenstick$expected = 1/10
# brokenstick$genposition = as.numeric(gsub("p", "", brokenstick$segment))/10
# brokenstick$logratio = log10(brokenstick$ratio)
# Take care of null values
# brokenstick$logratio[which(brokenstick$logratio == Inf)] = 1
# brokenstick$logratio[which(brokenstick$logratio == -Inf)] = -1

# Min-max normalization 
brokenstick$normalizedratio = NA
samples = unique(brokenstick$sample)
for (i in samples) {
  a = -1
  b = 1
  norm = a + (((brokenstick$ratio[which(brokenstick$sample == i)] - min(brokenstick$ratio[which(brokenstick$sample == i)], na.rm = TRUE)) * (b - a))/(max(brokenstick$ratio[which(brokenstick$sample == i)], na.rm = TRUE) - min(brokenstick$ratio[which(brokenstick$sample == i)], na.rm = TRUE)))
  brokenstick$normalizedratio[which(brokenstick$sample == i)] = norm
}

# log-transformed
brokenstick$logratio = log10(brokenstick$ratio)
brokenstick$logratio[which(brokenstick$logratio == -Inf)] = -1
brokenstick$logratio[which(brokenstick$logratio < -1)] = -1
brokenstick$logratio[which(brokenstick$logratio > 1)] = 1

# Scaling
brokenstick$scaledratio = scale(brokenstick$ratio)


df = merge(brokenstick, telomere_pattern, by = "set")
df$pattern = factor(df$pattern, levels = c("telomere", "peak", "exception"), labels = c("telomere", "peak", "exception"))


# Colors of labels
colorpalette= c("#D55E00", "#0072B2", "black")
# Order species same as the broken stick
col.labs = data.frame(set = brokenspecies$set)
col.labs$pattern = NA
for (i in 1:nrow(col.labs)) {
  col.labs$pattern[i] = as.character(telomere_pattern$pattern[which(telomere_pattern$set == col.labs$set[i])])
}
col.labs$color = ifelse(col.labs$pattern == "telomere", colorpalette[1], ifelse(col.labs$pattern == "peak", colorpalette[2], colorpalette[3]))


set.labs = paste("<span style='color:", col.labs$color,"'> <i>", col.labs$set, "</i> (", round(chrsize, digits = 0), " Mb)</span>", sep = "")
names(set.labs) = levels(brokenstick$set)

# p1a = ggplot(data = df, aes(x = sample, y = expected, group = segment, fill = normalizedratio))+
#   geom_bar(stat='identity', width = 1) +
#   scale_fill_viridis_c(breaks = c(-1, 0, 1), labels = c("-1", "0", "1"), direction = -1,
#                        limits = c(-1, 1), values = c(0,0.7,0.8,1), option = "D") +
#   scale_y_continuous(breaks = c(0, 0.5, 1), labels = c("0", "0.5", "1")) +
#   facet_grid(~set, scales = "free", space="fixed", labeller = labeller(set = set.labs)) +
#   labs(x="Chromosome", y="\nRelative physical length\n", fill="Relative recombination rate") +
#   theme(axis.line = element_blank(),
#         # axis.line.x = element_blank(), # No x axis
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
#         plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
#         axis.title.x = element_text(color="black", size=16),
#         axis.title.y = element_text(color="black", size=16),
#         axis.text=element_text(size=16, colour="black", angle = 0),
#         axis.text.x=element_blank(), # No samples names
#         axis.ticks.x=element_blank(), # No x axis
#         strip.text=ggtext::element_markdown(size=18, angle = 90, face = "plain"),
#         legend.key = element_rect(fill = "white", size = 1),
#         strip.background=element_rect(fill="white"),
#         legend.key.width=unit(0.8,"cm"),
#         legend.text=element_text(size=16, angle = 0),
#         legend.title=element_text(size=16),
#         legend.position = "bottom")
# 
# 
# 
# # Plotting the barplot
# # p1a = ggplot(data = brokenstick, aes(x = sample, y = expected, fill = ratio))+
# #   geom_bar(stat='identity', width = 1) +
# #   # scale_fill_manual(values = color) +
# #   # scale_fill_viridis_c(breaks = c(-0.5, 0), labels = c("-0.5", "0"), option = "viridis") +
# #   # scale_fill_viridis_c(breaks = c(-1, 0, 1), labels = c("-1", "0", "1"), direction = -1, limits = c(-1, 1),
# #   #                      values = c(0,0.7,0.8,1), option = "D") +
# #   scale_fill_viridis_c(breaks = c(-1, 0, 1), labels = c("-1", "0", "1"), direction = 1,
# #                        limits = c(-1, 1), values = c(0,0.2,0.3,1), option = "D") +
# #   scale_y_continuous(breaks = c(0, 0.5, 1), labels = c("0", "0.5", "1")) +
# #   # scale_fill_gradient2() +
# #   facet_grid(~set, scales = "free", space="fixed", labeller = labeller(set = set.labs)) +
# #   labs(x="Chromosome", y="\nRelative physical length\n", fill="Relative recombination rate") +
# #   theme(axis.line = element_blank(),
# #         # axis.line.x = element_blank(), # No x axis
# #         panel.grid.major = element_blank(),
# #         panel.grid.minor = element_blank(),
# #         panel.border = element_blank(),
# #         panel.background = element_blank(),
# #         plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
# #         plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
# #         axis.title.x = element_text(color="black", size=16),
# #         axis.title.y = element_text(color="black", size=16),
# #         axis.text=element_text(size=16, colour="black", angle = 0),
# #         axis.text.x=element_blank(), # No samples names
# #         axis.ticks.x=element_blank(), # No x axis
# #         strip.text=ggtext::element_markdown(size=18, colour="black", angle = 90, face = "plain"),
# #         legend.key = element_rect(fill = "white", size = 1),
# #         strip.background=element_rect(fill="white"),
# #         legend.key.width=unit(0.8,"cm"),
# #         legend.text=element_text(size=16, angle = 0),
# #         legend.title=element_text(size=16),
# #         legend.position = "bottom")
# # p1a
# p1 = p1a + geom_point(aes(x = sample, y = CI), size = 2, fill = "lightgray", color = "black", shape = 23)
# 
#----------------------------------------------------------------------------
# Adding covariates
#----------------------------------------------------------------------------
covariates = subset(brokenstick, brokenstick$segment == "p1")
covariates$proportion.length = rep(1, nrow(covariates))
covariates = covariates[,-c(4, 6)]
covariates$chr_size = NA
chromosome.stats$set = as.character(chromosome.stats$set)
chromosome.stats$chromosome = as.character(chromosome.stats$chromosome)
for (i in 1:nrow(covariates)) {
  covariates$chr_size[i] = chromosome.stats$phys.map.length[chromosome.stats$set == gsub("_[0-9A-Za-z]*$", "",covariates$sample[i]) & chromosome.stats$chromosome == covariates$chromosome[i]]
}
covariates$avgrecrate = NA
for (i in 1:nrow(covariates)) {
  covariates$avgrecrate[i] = chromosome.stats$mean.recrate[chromosome.stats$set == gsub("_[0-9A-Za-z]*$", "",covariates$sample[i]) & chromosome.stats$chromosome == covariates$chromosome[i]]
}
# rbarintra = read.table("tables/df_geneticshuffling_physical.csv", header = TRUE)
# brokenstick$rbarintra = NA
# for (i in 1:nrow(brokenstick)) {
#   brokenstick$rbarintra[i] = rbarintra$geneticshuffling[rbarintra$set == gsub("_[0-9A-Za-z]*$", "",brockenstick$sample[i])]
# }
# p2 = ggplot(data = covariates, aes(x = sample, y = chr_size, fill = chr_size)) +
#   geom_bar(stat='identity', width = 1) +
#   # scale_fill_manual(values = color) +
#   scale_fill_viridis_c(breaks = c(20, 50, 500), labels = c("20", "50", "500"), trans = "log", option = "inferno", direction = -1) +
#   # scale_fill_gradient2() +
#   facet_grid(~set, scales = "free", space="fixed") +
#   labs(x = "", y = "\n", fill = "Chromosome length (Mb)") +
#   theme(axis.line = element_blank(),
#         # axis.line.x = element_blank(), # No x axis
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
#         plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
#         axis.title.x = element_text(color="black", size=16),
#         axis.title.y = element_text(color="black", size=16),
#         axis.text=element_text(size=16, colour="white"),
#         axis.text.x=element_blank(), # No samples names
#         axis.ticks=element_blank(), # No axis ticks
#         strip.text=element_blank(),
#         legend.position = "bottom",
#         legend.direction = "horizontal",
#         legend.key = element_rect(fill = "white", size = 1),
#         legend.key.width=unit(0.8,"cm"),
#         legend.text=element_text(size=16, angle = 0),
#         legend.title=element_text(size=16),
#         plot.margin = margin(0, 0, 0, 0, "cm"))
# p2
# p3 = ggplot(data = covariates, aes(x = sample, y = proportion.length, fill = avgrecrate)) +
#   geom_bar(stat='identity', width = 1) +
#   scale_fill_viridis_c(breaks = c(0, 1, 10), labels = c("0", "1", "10"), trans = "log", option = "inferno") +
#   facet_grid(~set, scales = "free", space="fixed") +
#   labs(x="", y="\n", fill = "Genome-wide recombination rate (cM/Mb)") +
#   theme(axis.line = element_blank(),
#         # axis.line.x = element_blank(), # No x axis
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
#         plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
#         axis.title.x = element_text(color="black", size=16),
#         axis.title.y = element_text(color="black", size=16),
#         axis.text=element_text(size=16, colour="white"),
#         axis.text.x=element_blank(), # No samples names
#         axis.ticks=element_blank(), # No axis ticks
#         strip.text=element_blank(),
#         legend.position = "bottom",
#         legend.direction = "horizontal",
#         legend.key = element_rect(fill = "white", size = 1),
#         legend.key.width=unit(0.8,"cm"),
#         legend.text=element_text(size=16, angle = 0),
#         legend.title=element_text(size=16),
#         plot.margin = margin(0, 0, 0, 0, "cm"))
# # p3
# 
# # Aligning complex ggplots
# # gridExtra::grid.arrange provides no way to align the panels of individual plots. While this is achievable with low-level gtable functions, it often requires substantial effort on a case-by-case basis. The egg package introduces a general strategy for such layout manipulations, with the following steps:
# # decompose each plot into a 3x3 layout, where the central cell corresponds to the core panels, surrounded by axes, legends, etc.
# # set the core width and height to a fixed dimension
# # align the individual 3x3 gtables using rbind/cbind
# library(egg)
# g1 = ggplotGrob(p1)
# g2 = ggplotGrob(p2)
# g3 = ggplotGrob(p3)
# 
# fg1 = gtable_frame(g1, debug = TRUE,  height=unit(1,'null'))
# fg2 = gtable_frame(g2, debug = TRUE,  height=unit(1,'null'))
# fg3 = gtable_frame(g3, debug = TRUE,  height=unit(1,'null'))
# 
# egg::ggarrange(p1, p2, p3, ncol = 1, nrow = 3, heights = c(10,1,1),
#           labels = c("(A)", "(B)", "(C)"))
```

<!-- (ref:broken-stick-annotated) (ref:broken-stick-annotated) Structure of the recombination within chromosomes. Relative recombination rates along the chromosome estimated in ten bins under the broken stick model, with species ordered by ascending variance of relative recombination rates (n=665). (A) The relative recombination rate is the log-transformed ratio of the expected relative genomic length (one tenth) divided by observed relative genomic length. It means that values below zero are recombination rates lower than expected while values above zero are recombination rates higher than expected. When information is available, the centromere position on the chromosome is mapped as a red dot and chromosomes are oriented with the longer arm on top. (B) Chromosome length measured in Mb. (C) Genome-wide recombination rate, i.e. the mean recombination rate estimated in 100kb windows (cM/Mb). -->



#### Figure 4

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 15, fig.align="center", fig.cap = "(ref:broken-stick)"}
fontsize = 8
dotsize = 0.2
linesize = 0.6

#============================================================================
# Figures. Broken stick barplot solo
#============================================================================
# Plotting the barplot
p1a = ggplot(data = df, aes(x = sample, y = expected, group = segment, fill = logratio))+
  geom_bar(stat='identity', width = 1) +
  scale_fill_viridis_c(breaks = c(-1, 0, 1), labels = c("-1", "0", "1"), direction = -1,
                       limits = c(-1, 1), values = c(0,0.6,0.7,1), option = "D") +
  scale_y_continuous(breaks = c(0, 0.5, 1), labels = c("0", "0.5", "1")) +
  facet_grid(~set, scales = "free", space="fixed", labeller = labeller(set = set.labs)) +
  labs(x="Chromosomes", y="\nRelative genomic position\n", fill="Relative recombination rate") +
  theme(axis.line = element_blank(),
        # axis.line.x = element_blank(), # No x axis
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=fontsize,hjust = 0.5),
        # axis.title.x = element_text(color="black", size=fontsize, angle = 180),
        axis.title.x = element_blank(),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black", angle = 90, hjust = -4),
        axis.text.x=element_blank(), # No samples names
        axis.text.y = element_text(hjust = 0.5),
        axis.ticks.x=element_blank(), # No x axis
        strip.text=ggtext::element_markdown(size=fontsize-2, angle = 90, face = "plain"),
        legend.key = element_rect(fill = "white", size = 0.5),
        strip.background=element_rect(fill="white"),
        legend.key.width=unit(0.2,"cm"),
        legend.key.height=unit(0.3,"cm"),
        legend.text=element_text(size=fontsize-2, angle = 90, hjust = 0.5),
        legend.title=element_text(size=fontsize-2, angle = 90, hjust = 2, vjust = 1),
        legend.position = "right",
        legend.box = "horizontal")
# p1a
p1 = p1a + geom_point(aes(x = sample, y = CI), size = 0.6, fill = "white", color = "black", shape = 23)
# p1
# Space between panels
p1 = p1 + theme(panel.spacing = unit(0.1, "lines"))

# Add chromosome size
p2 = ggplot(data = covariates, aes(x = sample, y = chr_size)) +
  geom_bar(stat='identity', width = 1) +
  # scale_y_continuous(trans='log10') +
  # scale_fill_manual(values = color) +
  # scale_fill_viridis_c(option = "inferno", direction = 1) +
  # scale_fill_gradient2() +
  facet_grid(~set, scales = "free", space="fixed") +
  labs(x = "Chromosomes", y = "\nChr. size\n(Mb)") +
  theme(axis.line = element_blank(),
        # axis.line.x = element_blank(), # No x axis
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=fontsize,hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize, angle = 180),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text.y=element_text(size=fontsize, colour="white", angle = 90, hjust = -4),
        axis.text.x=element_blank(), # No samples names
        axis.ticks=element_blank(), # No axis ticks
        strip.text=element_blank(),
        legend.key = element_rect(fill = "white", size = 0.5),
        strip.background=element_rect(fill="white"),
        legend.key.width=unit(0.2,"cm"),
        legend.key.height=unit(0.3,"cm"),
        legend.text=element_text(size=fontsize-2, angle = 90, hjust = 0.5),
        legend.title=element_text(size=fontsize-2, angle = 90, hjust = 2, vjust = 1),
        legend.position = "none",
        legend.box = "horizontal",
        plot.margin = margin(0, 0, 0, 0, "cm"))
# p2
# Vertical plot
# p1 = p1 + coord_flip()
# p1
p2 = p2 + theme(panel.spacing = unit(0.1, "lines"))


g1 = ggplotGrob(p1)
g2 = ggplotGrob(p2)

fg1 = egg::gtable_frame(g1, debug = TRUE,  height=unit(1,'null'))
fg2 = egg::gtable_frame(g2, debug = TRUE,  height=unit(1,'null'))

plot = egg::ggarrange(p1, p2, ncol = 1, nrow = 2, heights = c(8,1),
          labels = c("", ""))


plot(plot)

ggsave(file = paste(wd, "figures/article_one/Fig4.tiff", sep = ""), plot = plot, width = 7.5, height = 4, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig4.jpeg", sep = ""), plot = plot, width = 7.5, height = 4, dpi = 300)
```

(ref:broken-stick) (ref:broken-stick) Structure of the recombination within chromosomes. relative recombination rates along the chromosome estimated in ten bins under the broken stick model, with species ordered by ascending variance of relative recombination rates (n=665). The relative recombination rate is the log-transformed ratio of the expected relative genetic length (one tenth) divided by observed relative genetic length. It means that values below zero are recombination rates lower than expected while values above zero are recombination rates higher than expected. When information is available, the centromere position on the chromosome is mapped as a red dot and chromosomes are oriented with the longer arm on top.





## Heterogeneity measures

### Comparative approach - choice of the statistic

Three statistics for heterogeneity:
* coefficient of variation
* Gini coefficient
* variance in broken stick proportions

Model comparison approach:

```{r echo = TRUE}
lm_model = lm(cv.recrate ~ phys.map.length, data = chromosome.stats)
AIC(lm_model)
BIC(lm_model)
r.squaredLR(lm_model)
# par(mfrow = c(2,2))
# plot(lm_model, which = c(1,2,3,5))
# par(mfrow = c(1,1))     
     
lm_model = lm(gini ~ phys.map.length, data = chromosome.stats)
AIC(lm_model)
BIC(lm_model)
r.squaredLR(lm_model)
# par(mfrow = c(2,2))
# plot(lm_model, which = c(1,2,3,5))
# par(mfrow = c(1,1)) 

lm_model = lm(brokenstick_pvariance_scaled ~ phys.map.length, data = chromosome.stats)
AIC(lm_model)
BIC(lm_model)
r.squaredLR(lm_model)
# par(mfrow = c(2,2))
# plot(lm_model, which = c(1,2,3,5))
# par(mfrow = c(1,1))
```

```{r echo = TRUE}
lm_model = lm(cv.recrate ~ phys.map.length, data = species.stats)
AIC(lm_model)
BIC(lm_model)
r.squaredLR(lm_model)

lm_model = lm(pvariance ~ phys.map.length, data = species.stats)
AIC(lm_model)
BIC(lm_model)
r.squaredLR(lm_model)
```



### Larger chromosomes have higher heterogeneity?

To test the hypothesis that larger chromosomes have a higher heterogeneity, we used the variance in broken stick segment sizes as a proxy of recombination heterogeneity. But we need to correct for species random effect.


### Broken stick variance

```{r echo = TRUE}
# Distribution of variables
hist(chromosome.stats$brokenstick_pvariance_scaled, breaks = 30, main = "", xlab = "Scaled broken stick variance")
```

Across species: Chromosomes pooled per species. Is there a common pattern across species?

```{r echo = TRUE}
nrow(species.stats)

# Model selection
# Linear regression
lm_model = lm(pvariance ~ phys.map.length, data = species.stats)
summary(lm_model)
AIC(lm_model)
BIC(lm_model)
# Quadratic regression
lm_model = lm(pvariance ~ phys.map.length + I(phys.map.length^2), data = species.stats)
summary(lm_model)
AIC(lm_model)
BIC(lm_model)
```

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:brokenstickvariance-species)"}
p= ggplot(data = species.stats, aes(x = phys.map.length, y = pvariance)) +
  geom_point() + 
  scale_x_log10() +
  geom_smooth(formula = y ~ x + I(x^2), method = "lm", col = "black") +
  xlab("Mean chromosome size (Mb)") + ylab("Broken stick variance") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
p
```
(ref:brokenstickvariance-species) The broken stick variance depends on the mean chromosome size across species (n = 38). The broken stick variance was log-transformed and scaled for comparison between species.


Within species: Chromosome-level correlation.

```{r echo = FALSE}
#----------------------------------------------------------------------------
# Number of crossovers (linkage map length) ~ Chromosome relative size
#----------------------------------------------------------------------------
# Linear regression fit
mod = lm(brokenstick_pvariance_scaled ~ log10(phys.map.length), data = chromosome.stats)
summary(mod)

# LMER
lmer.model = lmer(brokenstick_pvariance_scaled ~ log10(phys.map.length) + (log10(phys.map.length)|species), data = chromosome.stats)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```

Indeed, the adjusted R-squared of the linear model is low and the mixed model explains a low proportion of inter-species effect (R2m, marginal $R_2$), with a non-significant coefficient.


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:relativechromosomesize-linkagemaplength)"}
p = ggplot(data = chromosome.stats, aes(x = phys.map.length, y = brokenstick_pvariance_scaled)) +
  geom_point(aes(fill = species), pch=21) +
  geom_smooth(aes(colour = species), method = "lm", se = FALSE) +
  xlab("Chromosome size") + ylab("Variance in broken stick proportions") +
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = 1) +
  geom_abline(intercept = fixef(lmer.model)[[1]], slope = fixef(lmer.model)[[2]], linetype = "twodash", size = 1) +
  scale_x_log10() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
p
```



### Coefficient of variation

```{r echo = TRUE}
# Distribution of variables
hist(chromosome.stats$cv.recrate, breaks = 30, main = "", xlab = "Coefficient of variation")
```

Across species: Chromosomes pooled per species.


```{r echo = TRUE}
nrow(species.stats)

# Model selection
# Linear regression
lm_model = lm(cv.recrate ~ phys.map.length, data = species.stats)
summary(lm_model)
AIC(lm_model)
BIC(lm_model)
# Quadratic regression
lm_model = lm(cv.recrate ~ phys.map.length + I(phys.map.length^2), data = species.stats)
summary(lm_model)
AIC(lm_model)
BIC(lm_model)
```


```{r echo = FALSE}
# Estimate the correlation
species.stats$correlation_cvrecrate = NA
species.stats$correlation_cvrecrate_p = NA
for (i in 1:nrow(species.stats)) {
  species.stats$correlation_cvrecrate[i] = cor.test(chromosome.stats$phys.map.length[which(chromosome.stats$species == species.stats$species[i])], chromosome.stats$cv.recrate[which(chromosome.stats$species == species.stats$species[i])], method = "spearman")$estimate
    species.stats$correlation_cvrecrate_p[i] = cor.test(chromosome.stats$phys.map.length[which(chromosome.stats$species == species.stats$species[i])], chromosome.stats$cv.recrate[which(chromosome.stats$species == species.stats$species[i])], method = "spearman")$p.value
}

# Estimate the mean correlation with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(species.stats$correlation_cvrecrate, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)


# Results
hist(species.stats$correlation_cvrecrate, breaks = 30, main = "", xlab = "Spearman correlation")
abline(v = mean(boot), col = "red", lwd = 2)
abline(v = quantile(boot, 0.025), lty  = "dashed", col = "red", lwd = 2)
abline(v = quantile(boot, 0.975), lty  = "dashed", col = "red", lwd = 2)

```



Selected model for simplicity

```{r echo = TRUE}
# The mean species correlation estimated by 1,000 bootstraps
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

# Species correlations

summary(species.stats$correlation_cvrecrate)

cor.test(species.stats$cv.recrate, species.stats$phys.map.length, method = "spearman")

# Linear regression
lm_model = lm(cv.recrate ~ phys.map.length, data = species.stats)
summary(lm_model)
```



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:cvrecrate-species)"}
p1 = ggplot(data = species.stats, aes(x = phys.map.length, y = cv.recrate)) +
  geom_point(size = 4) + 
  scale_x_log10() +
  geom_smooth(formula = y ~ x, method = "lm", col = "black") +
  xlab("Mean chromosome size (Mb)") + ylab("Coefficient of variation") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p1
p2 = ggplot(data = species.stats, aes(x = correlation_cvrecrate)) +
  ylim(0, 6) +
  geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 6), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Spearman's correlation") + ylab("Count") +
  geom_vline(xintercept = mean(boot)) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p2

p = p1 + annotation_custom(ggplotGrob(p2), xmin = log10(200), xmax = log10(700), ymin = 0.3, ymax = 0.9)
p
```

(ref:cvrecrate-species) The coefficient of variation depends on the mean chromosome size across species (n = 38). The broken stick variance was log-transformed and scaled for comparison between species. The inset presents the distribution of Spearman's correlation within species between the coefficient of variation and chromosome length. Mean correlation and 95% C.I. estimated by 1,000 bootstraps.


Within species: Chromosome-level correlation.

```{r echo = FALSE}
#----------------------------------------------------------------------------
# Number of crossovers (linkage map length) ~ Chromosome relative size
#----------------------------------------------------------------------------
# Linear regression fit
mod = lm(cv.recrate ~ log10(phys.map.length), data = chromosome.stats)
summary(mod)

# LMER
lmer.model = lmer(cv.recrate ~ log10(phys.map.length) + (log10(phys.map.length)|species), data = chromosome.stats)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```

For the coefficient of variation, the adjusted R-squared of the linear model is low and the mixed model explains a low proportion of inter-species effect (R2m, marginal $R_2$), as well as for the broken stick model.


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:chromosomesize-cvrecrate)"}
p = ggplot(data = chromosome.stats, aes(x = phys.map.length, y = cv.recrate)) +
  geom_point(aes(fill = species), pch=21) +
  geom_smooth(aes(colour = species), method = "lm", se = FALSE) +
  xlab("Chromosome size") + ylab("Coefficient of variation") +
  geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2], size = 1) +
  geom_abline(intercept = fixef(lmer.model)[[1]], slope = fixef(lmer.model)[[2]], linetype = "twodash", size = 1) +
  scale_x_log10() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
p
```

(ref:chromosomesize-cvrecrate) The coefficient of variation within species does not always vary with chromosome size.




## Species-specific heterogeneity of recombination landscapes 

Test explicitly the hypothesis that recombination landscapes are species specific. The variance in broken stick proportions and coefficient of variation should be correlated to the species.

```{r echo = TRUE}
# Test the species effect
aov_mod = aov(brokenstick_pvariance_scaled ~ species, data = chromosome.stats)
summary(aov_mod)

lm_mod = lm(brokenstick_pvariance_scaled ~ species, data = chromosome.stats)
summary(lm_mod)
```

```{r echo = TRUE}
# Test the species effect
aov_mod = aov(cv.recrate ~ species, data = chromosome.stats)
summary(aov_mod)

lm_mod = lm(cv.recrate ~ species, data = chromosome.stats)
summary(lm_mod)
```





## COs are biased toward the periphery for many species

Estimate the bias toward the periphery.

```{r echo = TRUE, message = FALSE, warning = FALSE, include = TRUE}
# Estimate the mean periphery-bias ratio with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(chromosome.stats$peripherybias_ratio, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

# Results
hist(chromosome.stats$peripherybias_ratio, xlab = "Periphery-bias ratio", breaks = 30, main = "")
abline(v = 1, col = "black")
abline(v = mean(boot), col = "red", lwd = 2)
abline(v = quantile(boot, 0.025), lty  = "dashed", col = "red", lwd = 2)
abline(v = quantile(boot, 0.975), lty  = "dashed", col = "red", lwd = 2)


# How many maps have a periphery-bias ratio over 1 (i.e. more recombination at the tips than at the center)?
sum(chromosome.stats$peripherybias_ratio > 1, na.rm = TRUE)
# And in proportion
sum(chromosome.stats$peripherybias_ratio > 1, na.rm = TRUE)/nrow(chromosome.stats)

# How many maps have a periphery-bias ratio under 1 (i.e. more recombination at the center than on the tips)?
sum(chromosome.stats$peripherybias_ratio < 1, na.rm = TRUE)
# And in proportion
sum(chromosome.stats$peripherybias_ratio < 1, na.rm = TRUE)/nrow(chromosome.stats)
```
Sample size. 

```{r echo = TRUE}
# Sample size
nrow(species.stats)
```

Test which species have a significant periphery-bias ratio (supplementary table).


```{r echo = FALSE}
# Estimate the correlation
species.stats$correlation_peripherybias = NA
species.stats$correlation_peripherybias_p = NA
for (i in 1:nrow(species.stats)) {
  species.stats$correlation_peripherybias[i] = cor.test(chromosome.stats$phys.map.length[which(chromosome.stats$species == species.stats$species[i])], chromosome.stats$peripherybias_ratio[which(chromosome.stats$species == species.stats$species[i])], method = "spearman")$estimate
    species.stats$correlation_peripherybias_p[i] = cor.test(chromosome.stats$phys.map.length[which(chromosome.stats$species == species.stats$species[i])], chromosome.stats$peripherybias_ratio[which(chromosome.stats$species == species.stats$species[i])], method = "spearman")$p.value
}

# Estimate the mean correlation with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(species.stats$correlation_peripherybias, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)


# Results
hist(species.stats$correlation_peripherybias, breaks = 30, main = "", xlab = "Spearman correlation")
abline(v = mean(boot), col = "red", lwd = 2)
abline(v = quantile(boot, 0.025), lty  = "dashed", col = "red", lwd = 2)
abline(v = quantile(boot, 0.975), lty  = "dashed", col = "red", lwd = 2)

```


```{r echo = TRUE}
kable(species.stats[,c(1:4,9:10)], caption = "Species correlation between the periphery-bias ratio and chromosome length.", labels = c("Species", "Chromosome number", "Chromosome size", "Mean periphery-bias", "Spearman correlation", "p-value"), align = "c")
```




```{r echo = TRUE}
S6_peripherybias = species.stats[,c(1:4,9:10)]
colnames(S6_peripherybias) = c("Species", "Chromosome number", "Chromosome size", "Mean periphery-bias", "Spearman correlation", "p-value")

write.xlsx(x = S6_peripherybias, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S6_peripherybias", row.names = FALSE,
           append = TRUE)
rm(S6_peripherybias)
```



Is the correlation between the periphery-bias ratio and chromosome size significant across species? Chromosomes pooled per species.

```{r echo = TRUE}
nrow(species.stats)

# Model selection
# Linear regression
lm_model = lm(peripherybias_ratio ~ phys.map.length, data = species.stats)
summary(lm_model)
AIC(lm_model)
BIC(lm_model)
# Quadratic regression
lm_model = lm(peripherybias_ratio ~ phys.map.length + I(phys.map.length^2), data = species.stats)
summary(lm_model)
AIC(lm_model)
BIC(lm_model)
```

Selected model for simplicity: LM

```{r echo = TRUE}
# The mean species correlation estimated by 1,000 bootstraps
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

# Species correlations
summary(species.stats$correlation_peripherybias)

cor.test(species.stats$peripherybias_ratio, species.stats$phys.map.length, method = "spearman")

# Linear regression
lm_model = lm(peripherybias_ratio ~ log10(phys.map.length), data = species.stats)
summary(lm_model)
```


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:peripherybias-species)"}
# Estimate the mean periphery-bias ratio with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(chromosome.stats$peripherybias_ratio, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

p1 = ggplot(data = species.stats, aes(x = phys.map.length, y = peripherybias_ratio)) +
  geom_point(size = 4) + 
  scale_x_log10() +
  scale_y_continuous(breaks = c(0,1,2,3,4)) +
  geom_smooth(formula = y ~ x, method = "lm", col = "black") +
  geom_hline(aes(yintercept = 1), linetype = 2) +
  xlab("Mean chromosome size (Mb, log scale)") + ylab("Periphery-bias ratio") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')

p2 = ggplot(data = chromosome.stats, aes(x = peripherybias_ratio)) +
  # ylim(0, 5) +
  geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Periphery-bias ratio") + ylab("Count") +
  geom_vline(xintercept = 1, colour = "red") +
  geom_vline(xintercept = mean(boot)) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p2
p3 = ggplot(data = species.stats, aes(x = correlation_peripherybias)) +
  # ylim(0, 5) +
  # geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Spearman's coefficient") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p3

# p = p1 + annotation_custom(ggplotGrob(p2), xmin = log10(120), xmax = log10(750), ymin = 0.2, ymax = 2.2)
# p
ggpubr::ggarrange(p1, ggarrange(p2, p3, nrow = 2, labels = c("B", "C")), ncol = 2, widths = c(3,1), labels = c("A", ""))
```

(ref:peripherybias-species) (ref:peripherybias-species) The periphery-bias ratio depends on the mean chromosome size across species (n = 38). The linear regression line and its parametric 95% confidence interval were estimated in ggplot2. A periphery-bias ratio above one indicates that recombination rate in the tips of the chromosome are higher than the mean chromosome recombination rate. The inset presents the distribution of periphery-bias ratios (n = 665 chromosomes). The mean periphery-bias ratio and its 95% confidence interval (black solid and dashed lines) were estimated by 1,000 bootstraps. The theoretical value for equal recombination in the tips than the rest of the chromosome (periphery-bias ratio of one) is the red vertical line.



```{r include=FALSE}
tmp_species.stats = species.stats
tmp_species.stats$linkage.map.length = NA
for (i in 1:nrow(tmp_species.stats)) {
  tmp_species.stats$linkage.map.length[i] = mean(chromosome.stats$linkage.map.length.correctedHW[which(chromosome.stats$species == tmp_species.stats$species[i])], na.rm = TRUE)
}
```


```{r include=TRUE}
lm.mod = lm(peripherybias_ratio ~ linkage.map.length, data = tmp_species.stats)
summary(lm.mod)
```


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:peripherybias-linkagemaplength)"}
p1 = ggplot(data = tmp_species.stats, aes(x = linkage.map.length, y = peripherybias_ratio)) +
  geom_point(size = 4) + 
  scale_x_log10() +
  scale_y_continuous(breaks = c(0,1,2,3,4)) +
  geom_smooth(formula = y ~ x, method = "lm", col = "black") +
  xlab("Linkage map length (cM)") + ylab("Periphery-bias ratio") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
rm(tmp_species.stats)
p1
```
(ref:peripherybias-linkagemaplength) Linkage map length (i.e. crossover frequency) does not correlate with the periphery-bias ratio.







Is the relationship between chromosome size and the periphery-bias ratio universal within species?

```{r echo = TRUE, message = FALSE, warning = FALSE, include = TRUE}
qqPlot(sqrt(chromosome.stats$peripherybias_ratio), ylab = "Periphery-bias ratio")
cor.test(log10(chromosome.stats$phys.map.length), sqrt(chromosome.stats$peripherybias_ratio), method = "spearman")

# LINEAR MODEL
lm_model = lm(sqrt(peripherybias_ratio) ~ log10(phys.map.length), data = chromosome.stats)
summary(lm_model)
AIC(lm_model)

# LINEAR MIXED MODEL
lmer_model = lmer(sqrt(peripherybias_ratio) ~ log10(phys.map.length) + (1|species), data = chromosome.stats)
summary(lmer_model)
AIC(lmer_model)
```


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:chromosomesize-peripherybiasratio)"}
p = ggplot(data = chromosome.stats, aes(x = phys.map.length, y = peripherybias_ratio)) +
  geom_point(aes(fill = species), pch=21) +
  geom_smooth(aes(colour = species), method = "lm", se = FALSE) +
  xlab("Chromosome size") + ylab("Periphery-bias ratio") +
  geom_abline(intercept = lm_model$coefficients[1], slope = lm_model$coefficients[2], size = 1) +
  geom_abline(intercept = fixef(lmer_model)[[1]], slope = fixef(lmer_model)[[2]], linetype = "twodash", size = 1) +
  scale_x_log10() + scale_y_sqrt() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
p
```

(ref:chromosomesize-peripherybiasratio) The periphery-bias ratio increases with chromosome size across species, but the relationship does not stand within species.


### Sensitivity of the metric (periphery-bias ratio) to the sampling scale.


```{r echo=FALSE, fig.align="center", fig.cap="(ref:peripherybias-sensitivity)", fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
#----------------------------------------------------------------------------
# ASSESSING SENSITIVITY TO SAMPLING IN RATIO - HOW MANY BINS?
#----------------------------------------------------------------------------
# Compute a gradient ratio for all bin number
df = read.table(paste(wd, "output/dist2telomere/DistancesRelative_bins.txt", sep = ""), header = TRUE, stringsAsFactors = FALSE)

gradient_ratio = data.frame(set = rep(chromosomes$set, 20), chromosome = rep(chromosomes$chromosome, 20), bin = rep(1:20, each = nrow(chromosomes)), ratio = NA)
for (i in 1:nrow(gradient_ratio)) {
  subs = subset(df, set == gradient_ratio$set[i] & chromosome == gradient_ratio$chromosome[i])
  # gradient_ratio$ratio[i] = (sum(subs$rec.rate[c(1:gradient_ratio$bin[i])], na.rm = TRUE)/sum(subs$rec.rate, na.rm = TRUE))
  # gradient_ratio[i, j] = (mean(subs$rec.rate[c(1:j)], na.rm = TRUE)/mean(subs$rec.rate[c(j:20)], na.rm = TRUE))/mean(subs$rec.rate, na.rm = TRUE) # Standardized ratio by the mean recombination rate
  gradient_ratio$ratio[i] = (mean(subs$rec.rate[c(1:gradient_ratio$bin[i])], na.rm = TRUE)/mean(subs$rec.rate, na.rm = TRUE))
}

# Bootstrap C.I. for loess regression
# library(spatialEco)
# loess.boot = loess.boot(gradient_ratio$bin, gradient_ratio$ratio, nreps = 1000, confidence = 0.95)
# loess.boot
# loess.boot$fit
# plot(loess.boot)
# save(loess.boot, file = "output/gradient_peripherybiasratio_loessboot.Rda")
load(paste(wd, "output/gradient_peripherybiasratio_loessboot.Rda", sep = ""))
# loess.boot$fit

gradient_ratio_plot = ggplot() +
  geom_point(data = gradient_ratio, aes(x = bin, y = sqrt(ratio)), shape = 1, colour = "darkGrey") +
  # geom_smooth(aes(x = bin, y = log(ratio)), method = "loess", se = TRUE, level = 0.95) +
  geom_ribbon(data = loess.boot$fit, aes(x = x, ymin = sqrt(low.lim), ymax = sqrt(up.lim)), fill = "grey70") +
  geom_line(data = loess.boot$fit, aes(x = x, y = sqrt(y.fit))) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  xlab("Number of bins sampled at chromosome end") + ylab("Periphery-bias ratio\n(square root scale)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=9),
        axis.title.y = element_text(color="black", size=9),
        axis.text=element_text(size=9, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
gradient_ratio_plot
```

(ref:peripherybias-sensitivity) Sensitivity of the periphery-bias ratio metric to the sampling scale (i.e. the number of bins sampled at the tip of the chromosome). The periphery-bias ratio seems steady with an increasing number of bins sampled, though the ratio is slightly decreasing when more bins are sampled.


#### Figure S12

```{r include=FALSE}
fontsize = 12

# Compute a gradient ratio for all bin number
df = read.table(paste(wd, "output/dist2telomere/DistancesRelative_bins.txt", sep = ""), header = TRUE, stringsAsFactors = FALSE)

gradient_ratio = data.frame(set = rep(chromosomes$set, 20), chromosome = rep(chromosomes$chromosome, 20), bin = rep(1:20, each = nrow(chromosomes)), ratio = NA)
for (i in 1:nrow(gradient_ratio)) {
  subs = subset(df, set == gradient_ratio$set[i] & chromosome == gradient_ratio$chromosome[i])
  gradient_ratio$ratio[i] = (mean(subs$rec.rate[c(1:gradient_ratio$bin[i])], na.rm = TRUE)/mean(subs$rec.rate, na.rm = TRUE))
}

load(paste(wd, "output/gradient_peripherybiasratio_loessboot.Rda", sep = ""))

p = ggplot() +
  geom_point(data = gradient_ratio, aes(x = bin, y = (ratio)), shape = 1, colour = "darkGrey") +
  geom_ribbon(data = loess.boot$fit, aes(x = x, ymin = (low.lim), ymax = (up.lim)), fill = "grey70") +
  geom_line(data = loess.boot$fit, aes(x = x, y = (y.fit))) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  xlab("Number of bins sampled at chromosome end") + ylab("Periphery-bias ratio") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')

ggsave(file = paste(wd, "figures/article_one/FigS12.tiff", sep = ""), plot = p, width = 7, height = 5, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS12.jpeg", sep = ""), plot = p, width = 7, height = 5, dpi = 300)
```



# Telomeres and centromeres both influence the distribution of crossovers


## Telomere effect

Recombination rates increase with the distance to the nearest telomere.

Correlations between recombination rates and distance to the nearest telomere.

Test which species have a significant correlation with the distance to the telomere (supplementary table).

```{r message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------#
# Distribution of correlations between distance to telomere & recombination ----
#-------------------------------------------------------------#
# One correlation coefficient per chromosome
df_dist2telomere = read.table(paste(wd, "output/dist2telomere/AllChromosomes_Dist2telomeres.txt", sep = ""), header = TRUE)
library(plyr)
# Trim for NA values
df_dist2telomere_trimmed = subset(df_dist2telomere,
                                  !(is.na(df_dist2telomere$rec.rate) | is.na(df_dist2telomere$dist2telomere)))
cor_dist2telomere = ddply(df_dist2telomere_trimmed, c("set", "chromosome"), function(x) cor(x$rec.rate, x$dist2telomere, method = "spearman"))
colnames(cor_dist2telomere)[3] = "correlation"
# Add the p-value of the correlation test
cor_dist2telomere$pval = NA
for (i in 1:nrow(cor_dist2telomere)) {
  if (!is.na(cor_dist2telomere$correlation[i])) {
      cor_dist2telomere$pval[i] = cor.test(df_dist2telomere$rec.rate[which(df_dist2telomere$set == cor_dist2telomere$set[i] & df_dist2telomere$chromosome == cor_dist2telomere$chromosome[i])], df_dist2telomere$dist2telomere[which(df_dist2telomere$set == cor_dist2telomere$set[i] & df_dist2telomere$chromosome == cor_dist2telomere$chromosome[i])],method = "spearman")$p.value
  }
}
# Is the correlation significant?
cor_dist2telomere$signif = NA
for (i in 1:nrow(cor_dist2telomere)) {
  if (!is.na(cor_dist2telomere$pval[i])) {
      cor_dist2telomere$signif[i] = (cor_dist2telomere$pval[i] < 0.05)
  }
}
```


```{r echo = TRUE}
S7_correlationchromosomes = cor_dist2telomere[,1:4]
colnames(S7_correlationchromosomes) = c("Species", "Chromosome", "Spearman correlation", "p-value")

write.xlsx(x = S7_correlationchromosomes, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S7_correlationchromosomes", row.names = FALSE,
           append = TRUE)
rm(S7_correlationchromosomes)
```



Correlations at species and chromosome level

```{r echo = FALSE}
cor_dist2telomere$species = chromosome.stats$species
# Estimate the correlation correlation_dist2telomere/physical map length
species.stats$correlation_dist2telomere = NA
for (i in 1:nrow(species.stats)) {
  # Estimate: the mean correlation per species
  species.stats$correlation_dist2telomere[i] = mean(cor_dist2telomere$correlation[which(cor_dist2telomere$species == species.stats$species[i])], na.rm = TRUE)
}

# Estimate the mean correlation with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(species.stats$correlation_dist2telomere, replace = TRUE), na.rm = TRUE)
}
# mean(boot)
# quantile(boot, 0.025)
# quantile(boot, 0.975)


# Results
# hist(species.stats$correlation_peripherybias, breaks = 30, main = "", xlab = "Spearman correlation")
# abline(v = mean(boot), col = "red", lwd = 2)
# abline(v = quantile(boot, 0.025), lty  = "dashed", col = "red", lwd = 2)
# abline(v = quantile(boot, 0.975), lty  = "dashed", col = "red", lwd = 2)
```

```{r echo = TRUE}
# Sample size
nrow(species.stats)
```


```{r echo = TRUE}
kable(species.stats[,c(1:3,11)], caption = "Species correlation between the distance to the nearest telomere and the recombination rate.", labels = c("Species", "Chromosome number", "Chromosome size", "Spearman correlation"), align = "c")
```


```{r echo = TRUE}
S8_correlationspecies = species.stats[,c(1:3,11)]
colnames(S8_correlationspecies) = c("Species", "Chromosome number", "Chromosome size", "Spearman correlation")

write.xlsx(x = S8_correlationspecies, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S8_correlationspecies", row.names = FALSE,
           append = TRUE)
rm(S8_correlationspecies)
```



Selected model for simplicity: LM

```{r echo = TRUE}
# The mean species correlation estimated by 1,000 bootstraps
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

# Species correlations
summary(species.stats$correlation_dist2telomere)

cor.test(species.stats$correlation_dist2telomere, species.stats$phys.map.length, method = "spearman")

# Linear regression
lm_model = lm(correlation_dist2telomere ~ phys.map.length, data = species.stats)
summary(lm_model)
```



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:dist2telomere-species)"}
p1 = ggplot(data = species.stats, aes(x = phys.map.length, y = correlation_dist2telomere)) +
  geom_point(size = 4) + 
  scale_x_log10() +
  scale_y_continuous(breaks = c(0,1,2,3,4)) +
  geom_smooth(formula = y ~ x, method = "lm", col = "black") +
  xlab("Mean chromosome size (Mb)") + ylab("Spearman correlation") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')

p2 = ggplot(data = cor_dist2telomere, aes(x = correlation)) +
  geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Spearman correlation") + ylab("Count") +
  geom_vline(xintercept = 0, colour = "red") +
  geom_vline(xintercept = mean(boot)) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p2

p = p1 + annotation_custom(ggplotGrob(p2), xmin = log10(120), xmax = log10(750), ymin = -0.4, ymax = 0.4)
p
```

(ref:dist2telomere-species) (ref:dist2telomere-species) The negative correlation between recombination rates and the distance to the nearest telomere is stronger for species with a larger chromosome size (n = 57). The linear regression line and its parametric 95% confidence interval were estimated in ggplot2. The inset presents the distribution of Spearman correlation coefficients for chromosomes (n = 665 chromosomes). The mean correlation and its 95% confidence interval (black solid and dashed lines) were estimated by 1,000 bootstraps. The red vertical line is for a null correlation.

#### Figure S5

```{r include=FALSE}
fontsize = 12
pointsize = 3
linesize = 0.5

p1 = ggplot(data = species.stats, aes(x = phys.map.length, y = correlation_dist2telomere)) +
  geom_point(size = pointsize) + 
  scale_x_log10() +
  scale_y_continuous(breaks = c(0,1,2,3,4)) +
  geom_smooth(formula = y ~ x, method = "lm", col = "black") +
  geom_hline(aes(yintercept = 0), linetype = "dashed", size = linesize) +
  xlab("Mean chromosome size (Mb)") + ylab("Spearman's Rho") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')

p2 = ggplot(data = cor_dist2telomere, aes(x = correlation)) +
  geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  scale_x_continuous(breaks = c(-1, 0, 1)) +
  xlab("Spearman's Rho") + ylab("Count") +
  geom_vline(xintercept = 0, colour = "red") +
  geom_vline(xintercept = mean(boot)) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')
# p2

p = p1 + annotation_custom(ggplotGrob(p2), xmin = log10(225), xmax = log10(1000), ymin = -0.2, ymax = 0.6)
p

ggsave(file = paste(wd, "figures/article_one/FigS5.tiff", sep = ""), plot = p, width = 7, height = 5, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS5.jpeg", sep = ""), plot = p, width = 7, height = 5, dpi = 300)
```


Interestingly, at a species level, we can identify two groups of species. Although most species correlations are globally significant (i.e. a majority of significant chromosomes), there were a group of high negative correlations (lower than -0.5) and another one of lower/null correlations (between -0.5 and 0.1).

```{r message=FALSE, warning=FALSE, echo=FALSE}
# The mean correlation coefficient for a given species
spcorrelation = aggregate(correlation ~ species, data = cor_dist2telomere, mean)

# Percentage of significant correlations for a given species
spsignif = aggregate(signif ~ species, data = cor_dist2telomere, function(x) (sum(x)/length(x)))

# Average chromosome size
spchrsize = aggregate(phys.map.length ~ species, data = chromosome.stats, function(x) (mean(x, na.rm = TRUE)))

spcorr = merge(spcorrelation, spsignif, by = "species")
spcorr = merge(spcorr, spchrsize, by = "species")
spcorr$signif = round(spcorr$signif, digits = 2)
knitr::kable(spcorr, caption = "Species correlation between chromosome size and distance to the nearest telomere",
      label = c("Species", "Correlation", "Percentage of significant correlations", "Chromosome length"), align = "c", digits = 2)
```


Finally, to identify an inter-specific recurrent pattern, chromosomes were pooled per species. The relationship between recombination rates and the distance toward telomeres was assessed by quadratic regression with a Liner Mixed Model specifying a random species effect. Coefficients of the model and their confidence intervals at 95% were estimated with parametric bootstrap.


```{r message=FALSE, warning=FALSE, echo=FALSE}
#----------------------------------------------------------------------------#
# Chromosomes pooled per species ----
#----------------------------------------------------------------------------#
df_pooled = read.table(paste(wd, "output/dist2telomere/DistancesRelativeScaled_bins.txt", sep =""), header = TRUE)
# Quantiles of relative distances are pooled together
df_pooled$species = gsub("_[A-Za-z0-9]*$", "", df_pooled$set)
df_pooled$species = gsub("_MaizeGDBConsensus", "", df_pooled$species)
df_pooled$species = gsub("_", " ", df_pooled$species)

df_pooled = aggregate(df_pooled$rec.rate~df_pooled$dist2telomere+df_pooled$species, FUN=mean)
colnames(df_pooled) = c("dist2telomere", "species", "rec.rate")
```


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 9, fig.align="center", fig.cap = "(ref:DistancesRelative-pooledChromosomes)"}
DistancesRelative_pooledChromosomes = ggplot(data = df_pooled, aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Recombination rate (cM/Mb)") +
  geom_smooth(formula = y ~ x + I(x^2), method = "lm", se = TRUE, color = "Black") +
  # stat_smooth(aes(y = rec.rate), method = "lm", formula = y ~ x + I(x^2), size = 1, colour = "Black", fill = "DarkGrey", alpha = 0.3) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
DistancesRelative_pooledChromosomes
```

(ref:DistancesRelative-pooledChromosomes) Standardized recombination rate (cM/Mb) as a function of the relative distance from the telomere along the chromosome (physical distances expressed in 20 bins). Chromosomes were split in halves, distance 0.5 being the center of the chromosome. Then, chromosomes were pooled per species. Each color is a species. Linear quadratic regression estimated with a Linear Model is the black line (95% confidence interval in dark grey).


To uncover specific effects that could ultimately differ from the quadratic regression, I plotted loess regression lines over the pooled data.

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 12, fig.width = 12, fig.align="center", fig.cap = "(ref:DistancesRelative-pooledChromosomes-LOESS)"}
DistancesRelative_pooledChromosomes = ggplot(data = df_pooled, aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Recombination rate") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
DistancesRelative_pooledChromosomes
```

(ref:DistancesRelative-pooledChromosomes-LOESS) Standardized recombination rate (cM/Mb) as a function of the relative distance from the telomere along the chromosome (physical distances expressed in 20 bins). Chromosomes were split in halves, distance 0.5 being the center of the chromosome. Then, chromosomes were pooled per species. Each color is a species. A loess regression was estimated for each species.


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 12, fig.width = 12, fig.align="center"}
# Make 5 figures to identify species individually
species.names = unique(df_pooled$species)

DistancesRelative_pooledChromosomes_1 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[1:12]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Recombination rate") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
DistancesRelative_pooledChromosomes_1

DistancesRelative_pooledChromosomes_2 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[13:24]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Recombination rate") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
DistancesRelative_pooledChromosomes_2


DistancesRelative_pooledChromosomes_3 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[25:36]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Recombination rate") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
DistancesRelative_pooledChromosomes_3


DistancesRelative_pooledChromosomes_4 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[37:48]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Recombination rate") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
DistancesRelative_pooledChromosomes_4


DistancesRelative_pooledChromosomes_5 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[49:57]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Recombination rate") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
DistancesRelative_pooledChromosomes_5
```

#### Figure S6

```{r include=FALSE}
fontsize =12
linesize = 1

# Make 4 figures to identify species individually
species.names = unique(df_pooled$species)

p1 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[1:15]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate (cM/Mb)") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')

p2 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[16:30]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate (cM/Mb)") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')


p3 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[31:45]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate (cM/Mb)") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')

p4 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[46:57]),], aes(x = dist2telomere, y = rec.rate)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate (cM/Mb)") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')


p =ggpubr::ggarrange(p1, p2, p3, p4, ncol = 2, nrow = 2, labels = "AUTO") +
  theme(plot.margin = margin(1,1,1,1,"cm"))


ggsave(file = paste(wd, "figures/article_one/FigS6.tiff", sep = ""), plot = p, width = 14, height = 14, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS6.jpeg", sep = ""), plot = p, width = 14, height = 14, dpi = 300)
```



Classify species in three categories: telomere pattern, sub-telomere pattern and exceptions.


```{r echo = FALSE}
# Classify species in three categories:
# peak at 0, strictly in the telomere, i.e. telomere pattern
# peak outside the telomere, around 0.1-0.2, i.e. sub-telomere pattern
# exception, species following a unique pattern
telomere_pattern = data.frame(species = species.names, pattern = NA)
pattern_telomere = c("Aegilops speltoides", "Arachis duranensis", "Arachis hypogaea",
                     "Brachypodium distachyon", "Brassica napus", "Camelina sativa", "Capsicum annuum", "Cenchrus americanus",
                     "Citrullus lanatus", "Citrus sinensis", "Coffea canephora", "Cucumis melo",
                     "Dioscorea alata", "Glycine max", "Gossypium hirsutum", "Gossypium raimondii",
                     "Helianthus annuus", "Hordeum vulgare", "Lupinus albus", "Lupinus angustifolius",
                     "Oryza nivara", "Oryza sativa", "Phaseolus vulgaris", "Prunus mume", "Setaria italica",
                     "Solanum lycopersicum", "Solanum tuberosum", "Theobroma cacao", "Triticum aestivum",
                     "Triticum dicoccoides", "Triticum urartu", "Vigna unguiculata", "Vitis vinifera",
                     "Zea mays")
pattern_peak = c("Boechera stricta", "Brassica rapa", "Cucumis sativus", "Cucurbita maxima", "Cucurbita pepo", "Draba nivalis",
                 "Elaeis guineensis", "Juglans regia", "Malus domestica", "Mangifera indica", "Manihot esculenta",
                 "Momordica charantia", "Panicum hallii", "Prunus persica", "Sesamum indicum", "Sorghum bicolor")
pattern_exception = c("Arabidopsis thaliana", "Camellia sinensis", "Quercus sp", "Raphanus sativus", "Capsella rubella", "Eucalyptus grandis", "Nelumbo nucifera")

telomere_pattern$pattern[which(telomere_pattern$species %in% pattern_telomere)] = "telomere"
telomere_pattern$pattern[which(telomere_pattern$species %in% pattern_peak)] = "peak"
telomere_pattern$pattern[which(telomere_pattern$species %in% pattern_exception)] = "exception"

telomere_pattern$pattern = as.factor(telomere_pattern$pattern)
```

Exception patterns (6 species) tend to be higher at the center than on the rest of the chromosome. Interestingly, *Nelumbo nucifera* and *Camellia sinensis* are among these outlying patterns.

```{r echo = TRUE}
kable(telomere_pattern)
```


```{r echo = TRUE}
# The distribution of patterns among species
table(telomere_pattern$pattern)
```

```{r echo = TRUE}
chromosome.stats.telomere = merge(chromosome.stats, telomere_pattern)
boxplot(phys.map.length ~ pattern, data = chromosome.stats.telomere)

summary(chromosome.stats.telomere$phys.map.length[chromosome.stats.telomere$pattern == "telomere"], na.rm = TRUE)
summary(chromosome.stats.telomere$phys.map.length[chromosome.stats.telomere$pattern == "peak"], na.rm = TRUE)
summary(chromosome.stats.telomere$phys.map.length[chromosome.stats.telomere$pattern == "exception"], na.rm = TRUE)

wilcox.test(chromosome.stats.telomere$phys.map.length[chromosome.stats.telomere$pattern == "telomere"], chromosome.stats.telomere$phys.map.length[chromosome.stats.telomere$pattern == "peak"])
```

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 8, fig.width = 18, fig.align="center", fig.cap = "(ref:DistancesRelative-pooledChromosomes-patterns)"}
df_pooled = merge(df_pooled, telomere_pattern)

# colorpattern = as.character(telomere_pattern$pattern)
# colorpattern[which(colorpattern == "telomere")] = "black"
# colorpattern[which(colorpattern == "peak")] = "grey70"
# colorpattern[which(colorpattern == "exception")] = "grey39"

# Compute the ribbon for each type of pattern
ribbon = data.frame(pattern = rep(c("telomere","peak"), each = 40), x = rep(df_pooled$dist2telomere[1:40], 2), y = NA, ymin = NA, ymax = NA)
# Estimate ymin and ymax
for (i in 1:nrow(ribbon)) {
    ribbon$y[i] = mean(df_pooled$rec.rate[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = FALSE)
    ribbon$ymin[i] = min(df_pooled$rec.rate[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = TRUE)
  ribbon$ymax[i] = max(df_pooled$rec.rate[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = TRUE)
}
ribbon$pattern = factor(ribbon$pattern, levels = c("telomere", "peak", "exception"))

colorpalette= c("#D55E00", "#0072B2", "black")

### THE TELOMERE PATTERN
# chromosome.stats$phys.map.length[chromosome.stats$pattern == "telomere"]
sizedist_telopattern = ggplot(data = chromosome.stats.telomere[which(chromosome.stats.telomere$pattern == "telomere"),],
                               aes(x = pattern, y = phys.map.length)) +
  geom_violin(aes(), color = colorpalette[1], fill = colorpalette[1]) +
  ylim(0, 900) + ylab("Chromosome size (Mb)") +
  xlab("pattern") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        # axis.text=element_blank(),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

DistancesRelative_telopattern = ggplot(data = df_pooled[which(df_pooled$pattern == "telomere"),], aes(x = dist2telomere, y = rec.rate)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate") +
  ylim(-1.5, 3) +
  geom_point(aes(), color = colorpalette[1], alpha = 0.7, size = 3) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
DistancesRelative_telopattern = DistancesRelative_telopattern +
  geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = rec.rate, group = species), colour = "black", linetype = "dashed")
# Add smoothed line and ribbon
DistancesRelative_telopattern = DistancesRelative_telopattern +
  geom_line(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, y = y), color = colorpalette[1], size = 3) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[1], fill = colorpalette[1], alpha = 0.2, inherit.aes = FALSE)

#### THE PEAK PATTERN
sizedist_peakpattern = ggplot(data = chromosome.stats.telomere[which(chromosome.stats.telomere$pattern == "peak"),], aes(x = pattern, y = phys.map.length)) +
  geom_violin(aes(), color = colorpalette[2], fill = colorpalette[2]) +
  ylim(0, 900) + ylab("Chromosome size (Mb)") +
  xlab("pattern") +
  scale_x_discrete(labels = c("sub-telomeric")) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        # axis.text=element_blank(),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

DistancesRelative_peakpattern = ggplot(data = df_pooled[which(df_pooled$pattern == "peak"),], aes(x = dist2telomere, y = rec.rate)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate") +
  ylim(-1.5, 3) +
  geom_point(aes(), color = colorpalette[2], alpha = 0.7, size = 3) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
DistancesRelative_peakpattern = DistancesRelative_peakpattern +
  geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = rec.rate, group = species), colour = "black", linetype = "dashed")
# Add smoothed line and ribbon
DistancesRelative_peakpattern = DistancesRelative_peakpattern +
  geom_line(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, y = y), color = colorpalette[2], size = 3) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[2], fill = colorpalette[2], alpha = 0.2, inherit.aes = FALSE)

ggpubr::ggarrange(sizedist_telopattern, DistancesRelative_telopattern,
                  sizedist_peakpattern, DistancesRelative_peakpattern, ncol = 4, nrow = 1, widths = c(1,4,1,4))
```


(ref:DistancesRelative-pooledChromosomes-patterns) (ref:DistancesRelative-pooledChromosomes-patterns) Recombination rates are higher in distal regions and lower near the center of the chromosome. Standardized recombination rates (cM/Mb) as a function of the relative distance from the telomere along the chromosome (physical distances expressed in 20 bins). Two patterns were identified and species were pooled accordingly. Recombination rates decrease immediately from the tip of the chromosome for 35 species (dark grey line and ribbon) or recombination rate is reduced in telomeric regions and the peak of recombination is in a sub-telomeric region for 16 species (light grey line and ribbon). The solid line represents the mean recombination rate estimated in a bin and upper and lower boundaries of the ribbon represent the maximum and minimum values for a particular pattern. Besides, patterns that were not classified (6 species) were represented by loess regression in grey dashed lines. For estimating recombination rates in bins of relative distance, chromosomes were split in halves, a distance of 0.5 being the center of the chromosome. Then, chromosomes were pooled per species.

#### Figure 6

```{r include=FALSE}
fontsize = 10
linesize = 1
pointsize = 1

df_pooled = merge(df_pooled, telomere_pattern)

# colorpattern = as.character(telomere_pattern$pattern)
# colorpattern[which(colorpattern == "telomere")] = "black"
# colorpattern[which(colorpattern == "peak")] = "grey70"
# colorpattern[which(colorpattern == "exception")] = "grey39"

# Compute the ribbon for each type of pattern
ribbon = data.frame(pattern = rep(c("telomere","peak"), each = 40), x = rep(df_pooled$dist2telomere[1:40], 2), y = NA, ymin = NA, ymax = NA)
# Estimate ymin and ymax
for (i in 1:nrow(ribbon)) {
    ribbon$y[i] = mean(df_pooled$rec.rate[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = FALSE)
    ribbon$ymin[i] = min(df_pooled$rec.rate[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = TRUE)
  ribbon$ymax[i] = max(df_pooled$rec.rate[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = TRUE)
}
ribbon$pattern = factor(ribbon$pattern, levels = c("telomere", "peak", "exception"))

colorpalette= c("#D55E00", "#0072B2", "black")

### Chromosome sizes
chromosome.stats.telomere$pattern = factor(chromosome.stats.telomere$pattern, levels = c("telomere", "peak", "exception"))
# chromosome.stats.telomere$pattern = factor(chromosome.stats.telomere$pattern, levels = c("telomere", "peak", "exception"), labels = c("D", "SD", "E"))

sizedist = ggplot(data = chromosome.stats.telomere,
                               aes(x = pattern, y = phys.map.length)) +
  geom_violin(aes(color = pattern, fill = pattern)) +
  scale_color_manual(values = colorpalette) +
  scale_fill_manual(values = colorpalette) +
  ylim(0, 900) + ylab("Chrom. size (Mb)") +
  xlab("Pattern") +
  scale_x_discrete(labels = c("D", "SD", "E")) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text.x=element_text(size=fontsize, colour="black"),
        axis.text.y=element_text(size=fontsize, colour="black"),
        # axis.text=element_blank(),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')


### THE TELOMERE PATTERN
DistancesRelative_telopattern = ggplot(data = df_pooled[which(df_pooled$pattern == "telomere"),], aes(x = dist2telomere, y = rec.rate)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate") +
  ylim(-1.5, 3) +
  geom_point(aes(), color = colorpalette[1], alpha = 0.7, size = pointsize) +
  geom_text(aes(x = 0.25, y = 2.5, label = "Distal pattern\n(34 species)"), colour = colorpalette[1]) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
# DistancesRelative_telopattern = DistancesRelative_telopattern +
#   geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = rec.rate, group = species), colour = "black", linetype = "dashed")
# Add smoothed line and ribbon
DistancesRelative_telopattern = DistancesRelative_telopattern +
  geom_line(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, y = y), color = colorpalette[1], size = linesize) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[1], fill = colorpalette[1], alpha = 0.2, inherit.aes = FALSE)

#### THE PEAK PATTERN
DistancesRelative_peakpattern = ggplot(data = df_pooled[which(df_pooled$pattern == "peak"),], aes(x = dist2telomere, y = rec.rate)) +
  xlab("Relative distance to telomere") + ylab("Standardized recombination rate") +
  ylim(-1.5, 3) +
  geom_point(aes(), color = colorpalette[2], alpha = 0.7, size = pointsize) +
  geom_text(aes(x = 0.25, y = 2.5, label = "Sub-distal pattern\n(16 species)"), colour = colorpalette[2]) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
# DistancesRelative_peakpattern = DistancesRelative_peakpattern +
#   geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = rec.rate, group = species), colour = "black", linetype = "dashed")
# Add smoothed line and ribbon
DistancesRelative_peakpattern = DistancesRelative_peakpattern +
  geom_line(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, y = y), color = colorpalette[2], size = linesize) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[2], fill = colorpalette[2], alpha = 0.2, inherit.aes = FALSE)


tiffPlot = ggpubr::ggarrange(DistancesRelative_telopattern,
                  DistancesRelative_peakpattern, sizedist, ncol = 3, nrow = 1, hjust = 0.5,
                  labels = c("A", "B", "C"),
                  widths = c(4, 4, 3), font.label = list(size = 9)) +
  theme(plot.margin = margin(0.1,0.1,0.1,0.2, "cm"))

ggsave(file = paste(wd, "figures/article_one/Fig6.tiff", sep = ""), plot = tiffPlot, width = 7, height = 2.5, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig6.jpeg", sep = ""), plot = tiffPlot, width = 7, height = 2.5, dpi = 300)
```


### Figure 7


```{r include=FALSE}
fontsize = 10
linesize = 1
pointsize = 1
# Import the CO model schema as pdf graphics
p0 = magick::image_read(paste(wd, "figures/CO_model_v2.png", sep = ""))
p0 = as.grob(p0)

ggsave(file = paste(wd, "figures/article_one/Fig7.tiff", sep = ""), plot = p0, width = 5, height = 2, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig7.jpeg", sep = ""), plot = p0, width = 5, height = 2, dpi = 300)
```



Redraw the periphery-bias ratio with colors according to the classification of patterns.

```{r echo = TRUE}
# The mean species correlation estimated by 1,000 bootstraps
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

# Species correlations
summary(species.stats$correlation_peripherybias)
cor.test(species.stats$peripherybias_ratio, species.stats$phys.map.length, method = "spearman")

# Linear regression
lm_model = lm(peripherybias_ratio ~ phys.map.length, data = species.stats)
summary(lm_model)
```

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:peripherybias-species)"}
# Estimate the mean periphery-bias ratio with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(chromosome.stats$peripherybias_ratio, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

df = merge(species.stats, telomere_pattern, by = "species")
df$pattern = factor(df$pattern, levels = c("telomere", "peak", "exception"), labels = c("telomere", "peak", "exception"))

p1 = ggplot(data = df, aes(x = phys.map.length, y = peripherybias_ratio, color = pattern)) +
  geom_smooth(formula = y ~ x, method = "lm", col = "black") +
  geom_point(aes(), size = 4) +
  scale_color_manual(values = colorpalette) +
  scale_x_log10() +
  scale_y_continuous(breaks = c(0,1,2,3,4)) +
  geom_hline(aes(yintercept = 1), linetype = 2) +
  xlab("Mean chromosome size (Mb)") + ylab("Periphery-bias ratio") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p1

p2 = ggplot(data = chromosome.stats, aes(x = peripherybias_ratio)) +
  # ylim(0, 5) +
  geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Periphery-bias ratio") + ylab("Count") +
  geom_vline(xintercept = 1, colour = "red") +
  geom_vline(xintercept = mean(boot)) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p2
p3 = ggplot(data = species.stats, aes(x = correlation_peripherybias)) +
  # ylim(0, 5) +
  # geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Spearman's coefficient") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
# p3

# p = p1 + annotation_custom(ggplotGrob(p2), xmin = log10(120), xmax = log10(750), ymin = 0.2, ymax = 2.2)
# p
ggpubr::ggarrange(p1, ggarrange(p2, p3, nrow = 2, labels = c("B", "C")), ncol = 2, widths = c(3,1), labels = c("A", ""))
```

(ref:peripherybias-species) (ref:peripherybias-species) The periphery-bias ratio depends on the mean chromosome size across species (n = 38). The linear regression line and its parametric 95% confidence interval were estimated in ggplot2. A periphery-bias ratio above one indicates that recombination rate in the tips of the chromosome are higher than the mean chromosome recombination rate. The inset presents the distribution of periphery-bias ratios (n = 665 chromosomes). The mean periphery-bias ratio and its 95% confidence interval (black solid and dashed lines) were estimated by 1,000 bootstraps. The theoretical value for equal recombination in the tips than the rest of the chromosome (periphery-bias ratio of one) is the red vertical line.

#### Figure 5


```{r include="FALSE"}
fontsize = 10
pointsize = 2
# Estimate the mean periphery-bias ratio with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(chromosome.stats$peripherybias_ratio, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

df = merge(species.stats, telomere_pattern, by = "species")
df$pattern = factor(df$pattern, levels = c("telomere", "peak", "exception"), labels = c("telomere", "peak", "exception"))

labels = df$species
labels[which(!(labels %in% c("Capsella rubella", "Arabidopsis thaliana", "Nelumbo nucifera", "Zea mays", "Malus domestica", "Eucalyptus grandis", "Camellia sinensis", "Aegilops speltoides", "Triticum dicoccoides", "Cucumis sativus", "Sorghum bicolor", "Manihot esculenta", "Dioscorea alata", "Mangifera indica")))] = ""
df$labels = labels

p1 = ggplot(data = df, aes(x = phys.map.length, y = peripherybias_ratio, color = pattern)) +
  geom_smooth(formula = y ~ x, method = "lm", col = "black") +
  geom_point(aes(), size = pointsize) +
  scale_color_manual(values = colorpalette) +
  scale_x_log10() +
  scale_y_continuous(breaks = c(0,1,2,3,4)) +
  geom_hline(aes(yintercept = 1), linetype = 2) +
  ggrepel::geom_text_repel(aes(label = labels), min.segment.length = 0.05) +
  xlab("Mean chromosome size (Mb)") + ylab("Periphery-bias ratio") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')
# p1

p2 = ggplot(data = chromosome.stats, aes(x = peripherybias_ratio)) +
  # ylim(0, 5) +
  geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Periphery-bias ratio") + ylab("Count") +
  geom_vline(xintercept = 1, colour = "red") +
  geom_vline(xintercept = mean(boot)) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed", size = 0.2) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')
# p2
p3 = ggplot(data = species.stats, aes(x = correlation_peripherybias)) +
  # ylim(0, 5) +
  # geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
  geom_histogram() +
  xlab("Spearman's rho") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize),
        legend.position='none')

tiffPlot = ggpubr::ggarrange(p1, ggpubr::ggarrange(p2, p3, nrow = 2, labels = c("B", "C"), font.label = list(size = 9)), ncol = 2, widths = c(3,1), labels = c("A", ""), font.label = list(size = 9))

ggsave(file = paste(wd, "figures/article_one/Fig5.tiff", sep = ""), plot = tiffPlot, width = 6.5, height = 4, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig5.jpeg", sep = ""), plot = tiffPlot, width = 6.5, height = 4, dpi = 300)
```



## Centromere effect

### How many chromosomes have lower recombination in the centromere?

For each chromosome, estimate the recombination rate within the centromere (recombination rate of the 100 kb window overlapping the centromere position).

```{r echo = FALSE}
chromosome.stats$rec.in.centromere = NA

for (i in 1:nrow(chromosome.stats)) {
  set = chromosome.stats$set[i]
  chr = chromosome.stats$chromosome[i]
  ci =chromosome.stats$centromeric_index_position_oriented[i]
  if (!is.na(ci)) {
    map = read.table(paste0(wd, "output/recombination_maps/loess/100kbwind/", set, "_chromosome", chr, ".txt"), header = TRUE)
  chromosome.stats$rec.in.centromere[i] = map$rec.rate[which((map$phys - 0.05) < ci & (map$phys + 0.05) > ci)]
  } else {
    chromosome.stats$rec.in.centromere[i] = NA
  }
}
```


```{r echo = TRUE}
# How many chromosomes with a centromere position?
sum(!is.na(chromosome.stats$rec.in.centromere))

# How many chromosomes with no recombination in centromere
sum(chromosome.stats$rec.in.centromere == 0, na.rm = TRUE)
sum(chromosome.stats$rec.in.centromere == 0, na.rm = TRUE)/sum(!is.na(chromosome.stats$rec.in.centromere))

# How many chromosomes with less recombination in centromere than the chromosome averaged recombination rate?
sum(chromosome.stats$rec.in.centromere < chromosome.stats$mean.recrate, na.rm = TRUE)
sum(chromosome.stats$rec.in.centromere < chromosome.stats$mean.recrate, na.rm = TRUE)/sum(!is.na(chromosome.stats$rec.in.centromere))
```



Resampling test for each chromosome. Is the centromeric rec. rate significantly lower than the chromosome averaged rec. rate?

```{r echo = FALSE}
chromosome.stats$lower.average.recrate = NA
chromosome.stats$upper.average.recrate = NA
chromosome.stats$boot.average.recrate = NA

for (i in 1:nrow(chromosome.stats)) {
  set = chromosome.stats$set[i]
  chr = chromosome.stats$chromosome[i]
  map = read.table(paste0(wd, "output/recombination_maps/loess/100kbwind/", set, "_chromosome", chr, ".txt"), header = TRUE)
  nboot = 1000
  boot = numeric(nboot)
  for (j in 1:nboot) {
    boot[j] = mean(sample(map$rec.rate, replace = TRUE), na.rm = TRUE)
  }
  chromosome.stats$boot.average.recrate[i] = mean(boot, na.rm = TRUE)
  chromosome.stats$lower.average.recrate[i] = quantile(boot, 0.025, na.rm = TRUE)
  chromosome.stats$upper.average.recrate[i] = quantile(boot, 0.975, na.rm = TRUE)
}
```


```{r echo = TRUE}
# How many chromosomes with SIGNIFICANTLY less recombination in centromere than the chromosome averaged recombination rate?

# Resampling test. 1000 bootstraps.
sum(chromosome.stats$rec.in.centromere < chromosome.stats$lower.average.recrate, na.rm = TRUE)

sum(chromosome.stats$rec.in.centromere < chromosome.stats$lower.average.recrate, na.rm = TRUE)/sum(!is.na(chromosome.stats$rec.in.centromere))

# And significantly higher?
sum(chromosome.stats$rec.in.centromere > chromosome.stats$upper.average.recrate, na.rm = TRUE)

sum(chromosome.stats$rec.in.centromere > chromosome.stats$upper.average.recrate, na.rm = TRUE)/sum(!is.na(chromosome.stats$rec.in.centromere))
```


```{r echo = TRUE}
par(mfrow = c(1,2))
hist(chromosome.stats$rec.in.centromere, main = "", xlab = "Recombination in centromere", breaks = 50)
hist(chromosome.stats$boot.average.recrate, main = "", xlab = "Averaged recombination", breaks = 50)
par(mfrow = c(1,1))
```

### Formal test of a centromere effect

Proportion of chromosomes that are metacentric or sub-metacentric in the dataset (long arm/short arm ratio < 3).

```{r echo = TRUE}
ratio = rep(NA, nrow(chromosome.stats))
for (i in 1:nrow(chromosome.stats)) {
  ratio[i] = max(c(chromosome.stats$centromeric_index[i], (1-chromosome.stats$centromeric_index[i])))/min(c(chromosome.stats$centromeric_index[i], (1-chromosome.stats$centromeric_index[i])))
}
hist(ratio, main = "", breaks = 30)

sum(ratio < 3, na.rm = TRUE)/sum(!is.na(ratio))
```

With d(x) the genetic distance at the relative physical position x (x betwwen 0 and 1) and c the centromeric index.

(1) Haenel et al. (2018) telomere model assumes that d(1/2) = d(1) - d(1/2), hence d(1/2)/d(1) = 1/2

(2) If a centromere effect and 1 co/chromosome, d(c) 	= c x 50 + a x c
 and d(1) â d(c) = (1-c) x 50 + a x (1-c). So, d(c) / d(1) = c
 
(3) If a centromere effect and 1 co/chromosome arm, d(c) 	= 50 + a x c
 and d(1) â d(c) = 50 + a x (1-c). So, (d(c) -50) / (d(1) â 100) = c

For chromosomes with a centromeric index, we used the Marey map to compute the predictions of the model.

```{r echo = FALSE}
# Load Marey maps
AllMaps = read.table(paste(wd, "data-cleaned/marey_maps/AllMaps.txt", sep = ""), header = TRUE)
# Make the predictions dataset
predictions_centromereModels = chromosome.stats[,c("species", "set", "chromosome", "centromeric_index_position_oriented")]
predictions_centromereModels$pred_telomere = NA
predictions_centromereModels$pred_centromere_chromosome = NA
predictions_centromereModels$pred_centromere_arm = NA
predictions_centromereModels$centromeric_index = NA

predictions_centromereModels = subset(predictions_centromereModels, !is.na(predictions_centromereModels$centromeric_index_position_oriented))

for (i in 1:nrow(predictions_centromereModels)) {
  if (!is.na(predictions_centromereModels$centromeric_index_position_oriented[i])) {
    # subset the map
  map = subset(AllMaps, (AllMaps$set == predictions_centromereModels$set[i] & AllMaps$map == predictions_centromereModels$chromosome[i]))
  map$phys = map$phys/10^6
  # Centromeric Index is the observed value to compare to predictions
    predictions_centromereModels$centromeric_index[i] = predictions_centromereModels$centromeric_index_position_oriented[i]/max(map$phys, na.rm = TRUE)
  
  # Haenel prediction
  map_length = max(map$gen, na.rm = TRUE)
  middle = max(map$phys, na.rm = TRUE)/2
  predictions_centromereModels$pred_telomere[i] = max(map$gen[which(map$phys < middle)], na.rm = TRUE)/map_length
  
  # Centromere 1 co per chromosome prediction
  # d(c) / d(1) = c
  predictions_centromereModels$pred_centromere_chromosome[i] = max(map$gen[which(map$phys < predictions_centromereModels$centromeric_index_position_oriented[i])], na.rm = TRUE)/map_length
  
  # Centromere 1 co per arm prediction
  # (d(c) -50) / (d(1) â 100) = c
  # Problems with predictions higher than 1 (when ratio computed with longer arm)
  # Problem with negative values, when shorter arm < 50cM
  predictions_centromereModels$pred_centromere_arm[i] = (max(map$gen[which(map$phys < predictions_centromereModels$centromeric_index_position_oriented[i])], na.rm = TRUE) - 50)/(map_length - 100)
  }
  if (predictions_centromereModels$pred_centromere_arm[i] == Inf) {
    predictions_centromereModels$pred_centromere_arm[i] = NA
  }
  
}
```

Verify the predictions.

```{r echo = TRUE}
# How many predictions are negative for one CO per chromosome arm (i.e. shorter arm < 50cM)?
# Count:
sum((predictions_centromereModels$pred_centromere_arm < 0), na.rm = TRUE)
# Proportion:
sum((predictions_centromereModels$pred_centromere_arm < 0)/nrow(predictions_centromereModels), na.rm = TRUE)

```



```{r echo = TRUE}
par(mfrow = c(1,2))
hist(predictions_centromereModels$pred_telomere, xlab = "Predicted ratio", breaks = 30, main = "")
# Distribution centered on 0.5, but too much variance than expected under the strict telomere model of Haenel et al. (2018)
plot(rep(0.5, nrow(predictions_centromereModels)),
     predictions_centromereModels$pred_telomere, xlab = "Predicted", ylab = "Observed", main = "")
# The prediction of a ratio constant at 0.5 is rejected

hist(predictions_centromereModels$pred_centromere_chromosome, xlab = "Predicted ratio", breaks = 30, main = "")
plot(predictions_centromereModels$centromeric_index,
     predictions_centromereModels$pred_centromere_chromosome, xlab = "Predicted", ylab = "Observed", main = "")

hist(predictions_centromereModels$pred_centromere_arm, xlab = "Predicted ratio", breaks = 30, main = "")
plot(predictions_centromereModels$centromeric_index,
     predictions_centromereModels$pred_centromere_arm, xlab = "Predicted", ylab = "Observed", main = "")

# Manually remove predictions outside (0,1)
sum(predictions_centromereModels$pred_centromere_arm > 1 | predictions_centromereModels$pred_centromere_arm < 0, na.rm = TRUE)/sum(!is.na(predictions_centromereModels$pred_centromere_arm), na.rm = TRUE)


hist(predictions_centromereModels$pred_centromere_arm[which(predictions_centromereModels$pred_centromere_arm < 1 & predictions_centromereModels$pred_centromere_arm > 0)], xlab = "Predicted ratio", breaks = 30, main = "")
plot(predictions_centromereModels$centromeric_index[which(predictions_centromereModels$pred_centromere_arm < 1 & predictions_centromereModels$pred_centromere_arm > 0)],
     predictions_centromereModels$pred_centromere_arm[which(predictions_centromereModels$pred_centromere_arm < 1 & predictions_centromereModels$pred_centromere_arm > 0)], xlab = "Predicted", ylab = "Observed", main = "")
par(mfrow = c(1,1))
```

Estimate the correlation expected-observed for the best model: centromere with one crossover per chromosome.

```{r echo = TRUE}
# Sample size
nrow(predictions_centromereModels)
```

```{r echor = TRUE}
cor.test(predictions_centromereModels$centromeric_index,
     predictions_centromereModels$pred_centromere_chromosome,
     method = "spearman")
```

Make the figure.

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 6, fig.align="center", fig.cap = "(ref:centromere-predictions)"}
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(predictions_centromereModels$pred_centromere_chromosome, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)

p1 = ggplot(data = predictions_centromereModels, aes(x = centromeric_index, y = pred_centromere_chromosome)) +
  geom_point(size = 4) +
  geom_smooth(formula = y ~ x, method = "lm", col = "black", se = FALSE) +
  xlab("Observed") + ylab("Predicted") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
p1
# p2 = ggplot(data = predictions_centromereModels, aes(x = pred_centromere_chromosome)) +
#   geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
#   geom_histogram() +
#   xlab("Predicted") + ylab("Count") +
#   geom_vline(xintercept = mean(boot)) +
#   geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
#   geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
#   theme(axis.line = element_line(colour = "black"),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
#         axis.title.x = element_text(color="black", size=14),
#         axis.title.y = element_text(color="black", size=14),
#         axis.text=element_text(size=14, colour="black"),
#         legend.key = element_rect(fill = "white", size = 1),
#         legend.key.height = unit(2,"line"),
#         legend.key.width = unit(5,"line"),
#         legend.text=element_text(size=14),
#         legend.title=element_text(size=14),
#         legend.position='none')
# p2

# nboot = 1000
# boot = numeric(nboot)
# for (i in 1:nboot) {
#   boot[i] = mean(sample(predictions_centromereModels$pred_telomere, replace = TRUE), na.rm = TRUE)
# }
# mean(boot)
# quantile(boot, 0.025)
# quantile(boot, 0.975)
# 
# p3 = ggplot(data = predictions_centromereModels, aes(x = pred_telomere)) +
#   geom_rect(aes(xmin = quantile(boot, 0.025), xmax = quantile(boot, 0.975), ymin = 0, ymax = 5), alpha = 0.3, fill = "grey") +
#   geom_histogram() +
#   xlab("Predicted") + ylab("Count") +
#   geom_vline(xintercept = 0.5, color = "red") +
#   geom_vline(xintercept = mean(boot)) +
#   geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
#   geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
#   theme(axis.line = element_line(colour = "black"),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
#         axis.title.x = element_text(color="black", size=14),
#         axis.title.y = element_text(color="black", size=14),
#         axis.text=element_text(size=14, colour="black"),
#         legend.key = element_rect(fill = "white", size = 1),
#         legend.key.height = unit(2,"line"),
#         legend.key.width = unit(5,"line"),
#         legend.text=element_text(size=14),
#         legend.title=element_text(size=14),
#         legend.position='none')
# p3

# ggpubr::ggarrange(ggpubr::ggarrange(p3, p2, nrow = 2, labels = c("A", "B")), ggpubr::ggarrange(p1, labels = "C"), ncol = 2, nrow = 1, widths = c(1,2))
```

<!-- (ref:centromere-predictions) (ref:centromere-predictions) (A) Predictions telomere model. (B) Predictions centromere model with one mandatory crossover. (C) Correlation observed-predicted under the centromere model with one mandatory crossover. -->
(ref:centromere-predictions) (ref:centromere-predictions) Correlation observed-predicted under the centromere model with one mandatory crossover.


### Model selection

Model selection based on R2 across species.

```{r echor = TRUE}
centromere_modselection = data.frame(Model = c("Telomere", "Centromere (arm)", "Centromere (chromosome)", "Telomere (subset)", "Centromere (arm) (subset)", "Centromere (chromosome) (subset)", "Telomere (trueCI)", "Centromere (arm) (trueCI)", "Centromere (chromosome) (trueCI)"),	Expected = rep(c("d(1/2) / d(1) = 0.5", "(d(c) -50) / (d(1) â 100) = c", "d(c) / d(1) = c"), 3),	AdjustedRsquared = NA,	Pvalue = NA,	AIC = NA,	BIC = NA, Species = NA)

predictions_centromereModels$pred_centromere_arm[which(predictions_centromereModels$pred_centromere_arm == Inf)] = NA

mod = lm(pred_telomere ~ centromeric_index, data = predictions_centromereModels)
summary(mod)$r.squared
centromere_modselection$AdjustedRsquared[1] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[1] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[1] = AIC(mod)
centromere_modselection$BIC[1] = BIC(mod)

mod = lm(pred_centromere_arm ~ centromeric_index, data = predictions_centromereModels)
summary(mod)
centromere_modselection$AdjustedRsquared[2] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[2] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[2] = AIC(mod)
centromere_modselection$BIC[2] = BIC(mod)

mod = lm(pred_centromere_chromosome ~ centromeric_index, data = predictions_centromereModels)
summary(mod)
centromere_modselection$AdjustedRsquared[3] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[3] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[3] = AIC(mod)
centromere_modselection$BIC[3] = BIC(mod)
```


Linear regression and model selection based on R2 criterion within species with at least 5 chromosomes.

```{r include = FALSE}
# Species with at least 5 chromosomes
species = as.data.frame(table(predictions_centromereModels$species))
species = species[which(species$Freq >= 5),]
colnames(species) = c("species", "chr_number")
species$species = as.character(species$species)
species$mod1 = NA
species$mod2 = NA
species$mod3 = NA
species$bestmodel = NA # The best model
for (i in 1:nrow(species)) {
  mod1 = lm(pred_telomere ~ centromeric_index, data = predictions_centromereModels[which(predictions_centromereModels$species == species$species[i]),])
  mod2 = lm(pred_centromere_arm ~ centromeric_index, data = predictions_centromereModels[which(predictions_centromereModels$species == species$species[i]),])
  mod3 = lm(pred_centromere_chromosome ~ centromeric_index, data = predictions_centromereModels[which(predictions_centromereModels$species == species$species[i]),])
  species$mod1[i] = summary(mod1)$adj.r.squared
  species$mod2[i] = summary(mod2)$adj.r.squared
  species$mod3[i] = summary(mod3)$adj.r.squared
  species$bestmodel[i] = which.max(c(summary(mod1)$adj.r.squared,
                      summary(mod2)$adj.r.squared,
                      summary(mod3)$adj.r.squared))
}
```

```{r include = TRUE}
table(species$bestmodel)

centromere_modselection$Species[1] = sum(species$bestmodel == 1)
centromere_modselection$Species[2] = sum(species$bestmodel == 2)
centromere_modselection$Species[3] = sum(species$bestmodel == 3)
```


Redo model selection but on a subset of chromosomes with no chromosome arm below 50cM.

```{r echor = TRUE}
# Sample size: number of chromosomes:
nrow(predictions_centromereModels[which(predictions_centromereModels$pred_centromere_arm > 0),])
```


```{r echor = TRUE}
predictions_centromereModels_subset = predictions_centromereModels[which(predictions_centromereModels$pred_centromere_arm > 0),]

mod = lm(pred_telomere ~ centromeric_index, data = predictions_centromereModels_subset)
summary(mod)$r.squared
centromere_modselection$AdjustedRsquared[4] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[4] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[4] = AIC(mod)
centromere_modselection$BIC[4] = BIC(mod)

mod = lm(pred_centromere_arm ~ centromeric_index, data = predictions_centromereModels_subset)
summary(mod)
centromere_modselection$AdjustedRsquared[5] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[5] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[5] = AIC(mod)
centromere_modselection$BIC[5] = BIC(mod)

mod = lm(pred_centromere_chromosome ~ centromeric_index, data = predictions_centromereModels_subset)
summary(mod)
centromere_modselection$AdjustedRsquared[6] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[6] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[6] = AIC(mod)
centromere_modselection$BIC[6] = BIC(mod)
```


Linear regression and model selection based on R2 criterion within species with at least 5 chromosomes.

```{r include = FALSE}
# species_subset with at least 5 chromosomes
species_subset = as.data.frame(table(predictions_centromereModels_subset$species))
species_subset = species_subset[which(species_subset$Freq >= 5),]
colnames(species_subset) = c("species", "chr_number")
species_subset$species = as.character(species_subset$species)
species_subset$mod1 = NA
species_subset$mod2 = NA
species_subset$mod3 = NA
species_subset$bestmodel = NA # The best model
for (i in 1:nrow(species_subset)) {
  mod1 = lm(pred_telomere ~ centromeric_index, data = predictions_centromereModels_subset[which(predictions_centromereModels_subset$species == species_subset$species[i]),])
  mod2 = lm(pred_centromere_arm ~ centromeric_index, data = predictions_centromereModels_subset[which(predictions_centromereModels_subset$species == species_subset$species[i]),])
  mod3 = lm(pred_centromere_chromosome ~ centromeric_index, data = predictions_centromereModels_subset[which(predictions_centromereModels_subset$species == species_subset$species[i]),])
  species_subset$mod1[i] = summary(mod1)$adj.r.squared
  species_subset$mod2[i] = summary(mod2)$adj.r.squared
  species_subset$mod3[i] = summary(mod3)$adj.r.squared
  species_subset$bestmodel[i] = which.max(c(summary(mod1)$adj.r.squared,
                      summary(mod2)$adj.r.squared,
                      summary(mod3)$adj.r.squared))
}
```

```{r include = TRUE}
table(species_subset$bestmodel)

centromere_modselection$Species[4] = sum(species_subset$bestmodel == 1)
centromere_modselection$Species[5] = sum(species_subset$bestmodel == 2)
centromere_modselection$Species[6] = sum(species_subset$bestmodel == 3)
```


```{r include = FALSE}
centromere_modselection$AdjustedRsquared = round(centromere_modselection$AdjustedRsquared, digits = 4)
centromere_modselection$Pvalue = round(centromere_modselection$Pvalue, digits = 2)
centromere_modselection$Pvalue[which(centromere_modselection$Pvalue < 0.001) ]= "< 0.001"
centromere_modselection$AIC = round(centromere_modselection$AIC, digits = 1)
centromere_modselection$BIC = round(centromere_modselection$BIC, digits = 1)
```





Redo model selection but on a subset of chromosomes with a correct CI orientation assessed (remove wrong orientation) 50cM.

```{r echor = TRUE}
id = which(paste(predictions_centromereModels$set, predictions_centromereModels$chromosome) %in% paste(chromosome.stats$set[idx_wrongCIorientation], chromosome.stats$chromosome[idx_wrongCIorientation]))

paste(predictions_centromereModels$set[id], predictions_centromereModels$chromosome[id])

# Sample size: number of chromosomes:
nrow(predictions_centromereModels[-id,])
```


```{r echor = TRUE}
predictions_centromereModels_subset = predictions_centromereModels[-id,]

mod = lm(pred_telomere ~ centromeric_index, data = predictions_centromereModels_subset)
summary(mod)$r.squared
centromere_modselection$AdjustedRsquared[7] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[7] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[7] = AIC(mod)
centromere_modselection$BIC[7] = BIC(mod)

mod = lm(pred_centromere_arm ~ centromeric_index, data = predictions_centromereModels_subset)
summary(mod)
centromere_modselection$AdjustedRsquared[8] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[8] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[8] = AIC(mod)
centromere_modselection$BIC[8] = BIC(mod)

mod = lm(pred_centromere_chromosome ~ centromeric_index, data = predictions_centromereModels_subset)
summary(mod)
centromere_modselection$AdjustedRsquared[9] = summary(mod)$adj.r.squared
centromere_modselection$Pvalue[9] = summary(mod)$coefficients[2,4]
centromere_modselection$AIC[9] = AIC(mod)
centromere_modselection$BIC[9] = BIC(mod)
```


Linear regression and model selection based on R2 criterion within species with at least 5 chromosomes.

```{r include = FALSE}
# species_subset with at least 5 chromosomes
species_subset = as.data.frame(table(predictions_centromereModels_subset$species))
species_subset = species_subset[which(species_subset$Freq >= 5),]
colnames(species_subset) = c("species", "chr_number")
species_subset$species = as.character(species_subset$species)
species_subset$mod1 = NA
species_subset$mod2 = NA
species_subset$mod3 = NA
species_subset$bestmodel = NA # The best model
for (i in 1:nrow(species_subset)) {
  mod1 = lm(pred_telomere ~ centromeric_index, data = predictions_centromereModels_subset[which(predictions_centromereModels_subset$species == species_subset$species[i]),])
  mod2 = lm(pred_centromere_arm ~ centromeric_index, data = predictions_centromereModels_subset[which(predictions_centromereModels_subset$species == species_subset$species[i]),])
  mod3 = lm(pred_centromere_chromosome ~ centromeric_index, data = predictions_centromereModels_subset[which(predictions_centromereModels_subset$species == species_subset$species[i]),])
  species_subset$mod1[i] = summary(mod1)$adj.r.squared
  species_subset$mod2[i] = summary(mod2)$adj.r.squared
  species_subset$mod3[i] = summary(mod3)$adj.r.squared
  species_subset$bestmodel[i] = which.max(c(summary(mod1)$adj.r.squared,
                      summary(mod2)$adj.r.squared,
                      summary(mod3)$adj.r.squared))
}
```

```{r include = TRUE}
table(species_subset$bestmodel)

centromere_modselection$Species[7] = sum(species_subset$bestmodel == 1)
centromere_modselection$Species[8] = sum(species_subset$bestmodel == 2)
centromere_modselection$Species[9] = sum(species_subset$bestmodel == 3)
```


```{r include = FALSE}
# centromere_modselection$AdjustedRsquared = round(centromere_modselection$AdjustedRsquared, digits = 4)
# centromere_modselection$Pvalue = round(centromere_modselection$Pvalue, digits = 2)
# centromere_modselection$Pvalue[which(centromere_modselection$Pvalue < 0.001) ]= "< 0.001"
# centromere_modselection$AIC = round(centromere_modselection$AIC, digits = 1)
# centromere_modselection$BIC = round(centromere_modselection$BIC, digits = 1)
```






Save model selection...

```{r include = FALSE}
kable(centromere_modselection, digits = 2, align = "c")

centromere_modselection = centromere_modselection[,c(1:6)]

file.remove(paste(wd, "tables/article_one_supp/Table1_centromere_modelselection.xls", sep = ""))
write.xlsx(x = centromere_modselection, file = paste(wd, "tables/article_one_supp/Table1_centromere_modelselection.xls", sep = ""), sheetName = "Model selection", row.names = FALSE, append = FALSE)

write.xlsx(x = species, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S9_Selection_CO_model", row.names = FALSE, append = TRUE)

write.xlsx(x = species_subset, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S10_Selection_CO_model_subset", row.names = FALSE, append = TRUE)
```



# Genomic landscapes correlate to recombination landscapes

```{r include=FALSE}
# Trim dataset after quality control
# Trim species
trimspecies = c("Aegilops_speltoides", "Lupinus_angustifolius")
# Trim chromosomes
trimchromosomes = data.frame(species = c("Cucurbita_pepo",
                                         rep("Dioscorea_alata", 5),
                                         rep("Helianthus_annuus", 4),
                                         rep("Oryza_nivara", 5),
                                         rep("Sesamum_indicum", 8),
                                         rep("Vitis_vinifera", 6)),
                             chr = c("14",
                             "1", "7", "9", "18", "20",
                             "4", "6", "8", "11",
                             "4", "7", "9", "11", "12",
                             "1", "4", "7", "8", "9", "10", "12", "13",
                             "7", "10", "12", "13", "16", "18"))
```


```{r message=FALSE, warning=FALSE, echo=FALSE}
# Import all 100kb windows at once
openmap = function(x) {
  map = read.table(file = gzfile(paste(wd, "data-cleaned/genome/gene_count/", files[x], sep = "")), header = TRUE, sep = "\t")
  map$map = gsub(".txt.gz", "",files[x])
  map$chromosome = gsub("[A-Za-z0-9_]*_chromosome", "", map$map)
  map$species = gsub("_", " ", str_extract(unique(map$map), "^[A-Za-z]+_[a-z]+"))
  return(map)
}

library(data.table)  
files = list.files(path = paste(wd, "data-cleaned/genome/gene_count", sep = ""), pattern = "*.txt.gz")
temp = lapply(1:length(files), function(x) openmap(x))
data = rbindlist(temp)
rm(temp)
# Trim species
# data = data[-which(data$species %in% gsub("_", " ", trimspecies)),]
# Trim chromosomes
# data = data[-which(paste(gsub(" ", "_", data$species), data$chromosome, sep = "_") %in% paste( trimchromosomes$species, trimchromosomes$chr, sep = "_")),]

# Import data pooled in 20 bins
meanrecrate_genecount = read.table(paste(wd, "output/gene_count/meanrecrate_genecount.txt", sep = ""), header = TRUE)
# Trim species
meanrecrate_genecount = meanrecrate_genecount[-which(meanrecrate_genecount$species %in% trimspecies),]

meanrecrate_genecount_scaled = read.table(paste(wd, "output/gene_count/meanrecrate_genecount_scaled.txt", sep = ""), header = TRUE)
# Trim species
meanrecrate_genecount_scaled = meanrecrate_genecount_scaled[-which(meanrecrate_genecount_scaled$species %in% trimspecies),]
```

```{r message=FALSE, warning=FALSE, echo=FALSE}
annotated = data.frame(species = gsub(" ", "_", unique(chromosome.stats$species)))
annotated$annotation = annotated$species %in% gsub(" ", "_", unique(meanrecrate_genecount$species))
annotated = merge(annotated, metadata.clean[,c("species", "accession")], by = 'species')
```

```{r echo = TRUE}
# Sample size - Species
sum(annotated$annotation)
# Sample size - Chromosomes
length(unique(data$map))
```

```{r message=FALSE, warning=FALSE, echo=TRUE}
cat("Species with annotations that were integrated in the dataset:\n")
paste(annotated$species[annotated$annotation], annotated$accession[annotated$annotation])
```

```{r message=FALSE, warning=FALSE, echo=TRUE}
cat("Species without annotations:\n")
paste(annotated$species[!(annotated$annotation)], annotated$accession[!(annotated$annotation)])
```

Most species had rarely more than 20 genes in a single window and variance of the averaged recombination rate  increased in the upper range of gene counts (we also observed an inflection of the variance around 20 genes in raw data), hence for gene count the quadratic regression was fitted to a subset of windows with at most 20 genes. We considered that windows with more genes were less reliable than the rest of the genome (e.g. too much annotations, overlapping genes).


```{r message=FALSE, warning=FALSE, echo=TRUE}
hist(data$rec.rate, breaks = 100, main = "",
     xlab = "Recombination rate",
     xlim = c(0,20))

hist(data$gene_count, breaks = 100, main = "",
     xlab = "Gene count",
     xlim = c(0,50))

cat("Proportion of windows with a null recombination rate (i.e. < 0.001):\n")
sum(data$rec.rate < 0.001, na.rm = TRUE)/sum(!is.na(data$rec.rate), na.rm = TRUE)
```



```{r message=FALSE, warning=FALSE, echo=TRUE}
ggplot(data = meanrecrate_genecount, aes(x = gene_count, group = species)) +
  geom_density(alpha = 0.4) +
  labs(x = "Gene count") +
  geom_vline(aes(xintercept = 30)) +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "none",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
```

## Within species, chromosome-level

At a chromosome level, we expect that windows with more genes will exhibit higher recombination rates. We tested this prediction with a Spearman correlation on 100kb windows for each chromosome. Furthermore, I tested the significance of the correlation for each chromosome and the significance of the relationship among species with a Linear Mixed Model (not shown here) taking into account repeated measurement within species and the structure of the dataset (species and chromosomes were random effects).

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 4, fig.width = 4, fig.align="center"}
#----------------------------------------------------------------------------#
# Distribution of correlations between gene count & recombination ----
#----------------------------------------------------------------------------#
# Trim for NA values
data_trimmed = subset(data, !(is.na(data$rec.rate) | is.na(data$gene_count)))

cor_genecount = ddply(data_trimmed, c("species", "chromosome"), function(x) cor(x$rec.rate, x$gene_count, method = "spearman"))
colnames(cor_genecount)[3] = "correlation"

# Add the p-value of the correlation test
cor_genecount$pval = NA
for (i in 1:nrow(cor_genecount)) {
  if (!is.na(cor_genecount$correlation[i])) {
      cor_genecount$pval[i] = cor.test(data_trimmed$rec.rate[which(data_trimmed$species == cor_genecount$species[i] & data_trimmed$chromosome == cor_genecount$chromosome[i])], data_trimmed$gene_count[which(data_trimmed$species == cor_genecount$species[i] & data_trimmed$chromosome == cor_genecount$chromosome[i])],method = "spearman")$p.value
  }
}

# Is the correlation significant?
cor_genecount$signif = NA
for (i in 1:nrow(cor_genecount)) {
  if (!is.na(cor_genecount$pval[i])) {
      cor_genecount$signif[i] = (cor_genecount$pval[i] < 0.05)
  }
}

# Estimate the mean correlation with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(cor_genecount$correlation, replace = TRUE), na.rm = TRUE)
}
mean(boot)
quantile(boot, 0.025)
quantile(boot, 0.975)


hist(cor_genecount$correlation, freq = TRUE,
     breaks = 30, xlab = "Correlation", main = "")
```

```{r message=FALSE, warning=FALSE, echo=TRUE}
cat("Number of chromosomes analyzed:\n")
sum(!is.na(cor_genecount$correlation))

cat("Proportion of chromosomes with a significant Spearman correlation:\n")
sum(cor_genecount$signif, na.rm = TRUE)/sum(!is.na(cor_genecount$signif))
```




## Across species: Chromosomes pooled per species.

Is it a common pattern among species?


In order to assess the interspecific differences in the relationship between recombination rates and gene count, I pooled chromosomes per species.

```{r message=FALSE, warning=FALSE, echo=FALSE}
# The mean correlation coefficient for a given species
spcorrelation = aggregate(correlation ~ species, data = cor_genecount, mean)

# Percentage of significant correlations for a given species
spsignif = aggregate(signif ~ species, data = cor_genecount, function(x) (sum(x)/length(x)))

# Average chromosome size
spchrsize = aggregate(phys.map.length ~ species, data = chromosome.stats, function(x) (mean(x, na.rm = TRUE)))

# Number of chromosomes in the dataset
spnbchr = aggregate(phys.map.length ~ species, data = chromosome.stats, function(x) (length(x)))
# spnbchr = duplicated(chromosome.stats$species)

# Mean rec rate
sprecrate = aggregate(mean.recrate ~ species, data = chromosome.stats, function(x) (mean(x, na.rm = TRUE)))

spcorr = merge(spcorrelation, spsignif, by = "species")
spcorr = merge(spcorr, spnbchr, by = "species")
spcorr = merge(spcorr, spchrsize, by = "species")
spcorr = merge(spcorr, sprecrate, by = "species")
spcorr$signif = round(spcorr$signif, digits = 2)
```

```{r message=FALSE, warning=FALSE, echo=TRUE}
colnames(spcorr)[4] = "n"
kable(spcorr, digits = 2, align = "c", caption = "Species Spearman's rank correlation between recombination rates and gene number.")
hist(spcorr$correlation, breaks = 30, xlab = "Species Spearman correlation", main = "", xlim = c(-1,1))
abline(v = 0, col = "Red", lty = 2)
```



```{r echo = TRUE}
# df = spcorr[,1:4]
# colnames(df) = c("Species", "Mean correlation", "Proportion of significant correlations", "Number of chromosomes")
# write.xlsx(x = df, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S10_correlationRecombinationGenes", row.names = FALSE, append = TRUE)
```





Correlations seem uniformly distributed among species from zero to one. There is only few cases of negative correlation. The correlation previously inferred seems robust, yet the strength of the relationship vary greatly among species.
 
All chromosomes pooled, the mean recombination rate per gene count and confidence intervals at 95% were estimated for each species (1,000 bootstraps).



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 20, fig.width = 12, fig.align="center", fig.cap = "(ref:genecount-allspecies)"}
#============================================================================
# Rec rate ~ gene count, for each species, 2X2 plot
#============================================================================
# meanrecrate_genecount = read.table(paste(wd, "output/gene_count/meanrecrate_genecount.txt", sep = ""), header = TRUE)
# meanrecrate_genecount$species = gsub("_", " ", meanrecrate_genecount$species)

# FIGURES
# Divide the figure in 4 plots for visualization
# Divide in four subsets
d1 = meanrecrate_genecount[which(meanrecrate_genecount$species %in% unique(meanrecrate_genecount$species)[1:11]),]
d2 = meanrecrate_genecount[which(meanrecrate_genecount$species %in% unique(meanrecrate_genecount$species)[12:22]),]
d3 = meanrecrate_genecount[which(meanrecrate_genecount$species %in% unique(meanrecrate_genecount$species)[23:33]),]
d4 = meanrecrate_genecount[which(meanrecrate_genecount$species %in% unique(meanrecrate_genecount$species)[34:44]),]

# Add a x jitter per species
spe = unique(d1$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d1$gene_count[which(d1$species == s)] = d1$gene_count[which(d1$species == s)] + i
  i = i + 0.04
}
spe = unique(d2$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d2$gene_count[which(d2$species == s)] = d2$gene_count[which(d2$species == s)] + i
  i = i + 0.04
}
spe = unique(d3$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d3$gene_count[which(d3$species == s)] = d3$gene_count[which(d3$species == s)] + i
  i = i + 0.04
}
spe = unique(d4$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d4$gene_count[which(d4$species == s)] = d4$gene_count[which(d4$species == s)] + i
  i = i + 0.04
}

p1 = ggplot(data = d1, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
p2 = ggplot(data = d2, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
p3 = ggplot(data = d3, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
p4 = ggplot(data = d4, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))

ggarrange(p1, p2, p3, p4, ncol = 1, nrow = 4)
```

(ref:genecount-allspecies) (ref:genecount-allspecies) Recombination rate (cM/Mb) depends on the gene count for 44 species (chromosomes pooled per species). Mean recombination rates and confidence intervals (95%) estimated by 1,000 bootstraps. Gene count was made by counting the number of gene starting positions within the window.


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 20, fig.width = 12, fig.align="center", fig.cap = "(ref:genecount-allspecies)"}
#============================================================================
# Rec rate ~ gene count, for each species, 2X2 plot
#============================================================================
# meanrecrate_genecount = read.table(paste(wd, "output/gene_count/meanrecrate_genecount.txt", sep = ""), header = TRUE)
# meanrecrate_genecount$species = gsub("_", " ", meanrecrate_genecount$species)

# FIGURES
# Divide the figure in 4 plots for visualization
# Divide in four subsets
d1 = meanrecrate_genecount_scaled[which(meanrecrate_genecount_scaled$species %in% unique(meanrecrate_genecount_scaled$species)[1:11]),]
d2 = meanrecrate_genecount_scaled[which(meanrecrate_genecount_scaled$species %in% unique(meanrecrate_genecount_scaled$species)[12:22]),]
d3 = meanrecrate_genecount_scaled[which(meanrecrate_genecount_scaled$species %in% unique(meanrecrate_genecount_scaled$species)[23:33]),]
d4 = meanrecrate_genecount_scaled[which(meanrecrate_genecount_scaled$species %in% unique(meanrecrate_genecount_scaled$species)[34:44]),]

# Add a x jitter per species
spe = unique(d1$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d1$gene_count[which(d1$species == s)] = d1$gene_count[which(d1$species == s)] + i
  i = i + 0.04
}
spe = unique(d2$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d2$gene_count[which(d2$species == s)] = d2$gene_count[which(d2$species == s)] + i
  i = i + 0.04
}
spe = unique(d3$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d3$gene_count[which(d3$species == s)] = d3$gene_count[which(d3$species == s)] + i
  i = i + 0.04
}
spe = unique(d4$species)
i = 0
for (s in spe) {
  # cat(s, "\n")
  d4$gene_count[which(d4$species == s)] = d4$gene_count[which(d4$species == s)] + i
  i = i + 0.04
}

p1 = ggplot(data = d1, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
p2 = ggplot(data = d2, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
p3 = ggplot(data = d3, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
p4 = ggplot(data = d4, aes(x = gene_count, y = mean_rec, colour = species)) +
  geom_line() +
  geom_point() +
  geom_pointrange(aes(ymin = lower_rec, ymax = upper_rec)) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 7)) +
  labs(x = "Gene count", y = "Recombination rate", colour = "Species") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "right",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))

ggarrange(p1, p2, p3, p4, ncol = 1, nrow = 4)
```

We see that the strength of the pattern varies among species. Intuitively, we can think that the slope of the relationship may depend on chromosome size, as many other patterns already observed.

``` {r echor = TRUE}
# cor_genecount = merge(cor_genecount, chromosome.stats[,c(1, 3, 8)])
# plot(x = cor_genecount$phys.map.length, y = cor_genecount$correlation,
#      log = "x")

# Estimate the slope of the relationship for each species
# Data = 100kb windows

# Estimate the slope of the relationship for each species
# Data = pooled chromosomes, recombination rate per gene count
spcorr$intercept = NA
spcorr$slope = NA
for (i in 1:nrow(spcorr)) {
  subset = meanrecrate_genecount[which(gsub("_", " ", meanrecrate_genecount$species) == spcorr$species[i]),]
  lm_model = lm(mean_rec ~ gene_count, data = subset)
  spcorr$intercept[i] = lm_model$coefficients[1]
  spcorr$slope[i] = lm_model$coefficients[2]
}

# predictions not verified
# None effect of chromosome length
plot(x = spcorr$phys.map.length, y = spcorr$slope,
     log = "x")
cor.test(x = spcorr$phys.map.length, y = spcorr$slope,
         method = "spearman")

# And mean recombination rate?
plot(x = spcorr$mean.recrate, y = spcorr$slope,
     log = "x", xlab = "Mean recombination rate",
     ylab = "Slope")
# Significance of teh relatiionship
cor.test(x = spcorr$mean.recrate, y = spcorr$slope,
         method = "spearman")
summary(lm(slope ~ mean.recrate, data = spcorr))
```


## Is it a common pattern among species?


```{r echo = FALSE, message = FALSE, warning = FALSE}
#============================================================================
# Rec rate ~ gene count, all species pooled (dark grey transparent dots) + quadratic phylogenetic regression with C.I.
#============================================================================
# meanrecrate_genecount = read.table(paste(wd, "output/gene_count/meanrecrate_genecount.txt", sep = ""), header = TRUE)
# meanrecrate_genecount$species = gsub("_", " ", meanrecrate_genecount$species)
# Subset only for a gene count <= 20
meanrecrate_genecount_subset = meanrecrate_genecount[which(meanrecrate_genecount$gene_count < 21),]

# Scale the recombination rate
# This way show differences in recombination rates across species
# meanrecrate_genecount$mean_rec = scale(meanrecrate_genecount$mean_rec)
# meanrecrate_genecount$lower_rec = scale(meanrecrate_genecount$lower_rec)
# meanrecrate_genecount$upper_rec = scale(meanrecrate_genecount$upper_rec)

# Scale the recombination rate within species
# The common pattern is less evident/clear
list_species = unique(meanrecrate_genecount_subset$species)
for (i in 1:length(list_species)) {
  meanrecrate_genecount_subset$mean_rec[which(meanrecrate_genecount_subset$species == list_species[i])] = scale(meanrecrate_genecount_subset$mean_rec[which(meanrecrate_genecount_subset$species == list_species[i])])
meanrecrate_genecount_subset$lower_rec[which(meanrecrate_genecount_subset$species == list_species[i])] = scale(meanrecrate_genecount_subset$lower_rec[which(meanrecrate_genecount_subset$species == list_species[i])])
meanrecrate_genecount_subset$upper_rec[which(meanrecrate_genecount_subset$species == list_species[i])] = scale(meanrecrate_genecount_subset$upper_rec[which(meanrecrate_genecount_subset$species == list_species[i])])
}
```


```{r echo = TRUE, message = FALSE, warning = FALSE}
summary(lm(mean_rec ~ gene_count, data = meanrecrate_genecount_subset))
```

Quadratic regression.

```{r echo = TRUE, message = FALSE, warning = FALSE}
summary(lm(mean_rec ~ gene_count + I(gene_count^2), data = meanrecrate_genecount_subset))
```



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 12, fig.align="center", fig.cap = "(ref:genecount-quadraticregression)"}
# FIGURES
p1 = ggplot(data = meanrecrate_genecount_subset, aes(x = gene_count, y = mean_rec)) +
  geom_smooth(formula = y ~ x + I(x^2), method = "lm", se = TRUE, colour = "Black") +
  geom_point(aes(colour = species)) +
  geom_segment(aes(x = gene_count, xend = gene_count, y = lower_rec, yend = upper_rec, colour = species)) +
  # stat_smooth(aes(y = mean_rec), method = "lm", formula = y ~ x + I(x^2), size = 1, colour = "Blue", fill = "Blue", alpha = 0.3) +
  scale_x_continuous(limits = c(0, 30)) +
  # scale_y_continuous(limits = c(0, 6)) +
  labs(x = "Gene count", y = "Standardized recombination rate") +
  # geom_abline(intercept = fixef(pglmm.model)[[1]][1], slope = fixef(pglmm.model)[[1]][2]) + # The PGLMM regression line
  # stat_function(fun = quadrafun, colour = "Black", size = 1) +
  # geom_ribbon(data = df.new, aes(x = gene_count, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "none",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
# p1

# Estimate the mean correlation with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(cor_genecount$correlation, replace = TRUE), na.rm = TRUE)
}
# mean(boot)
# quantile(boot, 0.025)
# quantile(boot, 0.975)
cor_genecount_pattern = merge(telomere_pattern, cor_genecount, by = "species")

p2 = ggplot(data = cor_genecount_pattern, aes(x = correlation, fill = pattern)) +
  geom_histogram() +
  geom_vline(aes(xintercept = 0), color = "Red") +
  scale_fill_manual(values = c("black", colorpalette[2], colorpalette[1])) +
  xlab("Spearman's correlation") + ylab("Count") +
  geom_vline(xintercept = mean(boot)) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed") +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "none",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))
# p2
spcorr_pattern = merge(spcorr, telomere_pattern, by = "species")

p3 = ggplot(data = spcorr_pattern, aes(x = mean.recrate, y = slope)) +
  geom_point(aes(color = pattern)) +
  # geom_smooth(aes(color = pattern), method = "lm", se = FALSE) +
  scale_color_manual(values = c("black", colorpalette[2], colorpalette[1])) +
  geom_smooth(method = "lm", se = FALSE, color = "Black") +
  xlab("Recombination rate (cM/Mb)") + ylab("Slope") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=16, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=16,hjust = 0.5),
        axis.title.x = element_text(color="black", size=16),
        axis.title.y = element_text(color="black", size=16),
        axis.text=element_text(size=16, colour="black"),
        strip.text=element_text(size=12, colour="black", angle = 90),
        legend.position = "none",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=16))


# p = p1 + annotation_custom(ggplotGrob(p2), xmin = 0.1, xmax = 7, ymin = 2.5, ymax = 4.5)
# p
ggpubr::ggarrange(ggpubr::ggarrange(p2, p3, nrow = 2, labels = c("A", "B")), ggpubr::ggarrange(p1, labels = "C"), ncol = 2, nrow = 1, widths = c(1,3))

# rm(cor_genecount_pattern)
# rm(spcorr_pattern)
```

(ref:genecount-quadraticregression) (ref:genecount-quadraticregression) Recombination rate depends on the gene count for 44 species both across and within species (A) Mean recombination rates (chromosomes pooled per species, one color per species) estimated by 1,000 bootstraps and standardized within species. Gene count was made by counting the number of gene starting positions within 100kb windows with a recombination rate. Black line with grey ribbon is the quadratic regression estimated by linear regression. (B) Distribution of chromosome Spearman rank correlations between the number of genes and the recombination rate in 100kb windows (n = 488 chromosomes). The black vertical lines are the mean correlation across chromosomes (solid) and 95% confidence interval (dashed) estimated by 1,000 bootstraps. (C) Slope of the species linear regression between gene count and recombination rates. Linear regression estimated on chromosome-level data with recombination rates estimated in quantiles of gene count. The linear regression is not significant (p = 0.72).


#### Figure 8


```{r include=FALSE}
fontsize = 9
pointsize = 1
linesize = 0.2

# FIGURES
p1 = ggplot(data = meanrecrate_genecount_subset, aes(x = gene_count, y = mean_rec)) +
  geom_jitter(aes(), colour = "darkgrey", size = pointsize, width = 0.1, height = 0) +
    geom_smooth(formula = y ~ x + I(x^2), method = "lm", se = TRUE, colour = "Black", size = linesize + 0.3) +
  scale_x_continuous(limits = c(0, 20)) +
  labs(x = "Gene count", y = "Standardized recombination rate") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=fontsize,hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        strip.text=element_text(size=fontsize, colour="black", angle = 90),
        legend.position = "none",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize))
# p1

# Estimate the mean correlation with bootstrapped C.I.
nboot = 1000
boot = numeric(nboot)
for (i in 1:nboot) {
  boot[i] = mean(sample(cor_genecount$correlation, replace = TRUE), na.rm = TRUE)
}
# mean(boot)
# quantile(boot, 0.025)
# quantile(boot, 0.975)
cor_genecount_pattern = merge(telomere_pattern, cor_genecount, by = "species")

p2 = ggplot(data = cor_genecount_pattern, aes(x = correlation, fill = pattern)) +
  geom_histogram() +
  geom_vline(aes(xintercept = 0), color = "Red", size = linesize) +
  scale_fill_manual(values = c("black", "dodgerblue3", colorpalette[1])) +
  xlab("Spearman's rho") + ylab("Count") +
  geom_vline(xintercept = mean(boot), size = linesize+0.3) +
  geom_vline(xintercept = quantile(boot, 0.025), linetype = "dashed", size = linesize) +
  geom_vline(xintercept = quantile(boot, 0.975), linetype = "dashed", size = linesize) +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=fontsize,hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        strip.text=element_text(size=fontsize, colour="black", angle = 90),
        legend.position = "none",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize))
# p2
spcorr_pattern = merge(spcorr, telomere_pattern, by = "species")

p3 = ggplot(data = spcorr_pattern, aes(x = mean.recrate, y = slope)) +
  geom_point(aes(color = pattern), size = pointsize) +
  scale_color_manual(values = c("black", "dodgerblue3", colorpalette[1])) +
  geom_smooth(method = "lm", se = FALSE, color = "Black", size = linesize+0.3) +
  xlab("Rec. rate (cM/Mb)") + ylab("Slope") +
  theme(axis.line = element_line(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        plot.subtitle = element_text(color="black",size=fontsize,hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        strip.text=element_text(size=fontsize, colour="black", angle = 90),
        legend.position = "none",
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.width=unit(2,"cm"),
        legend.text=element_text(size=fontsize),
        legend.title=element_text(size=fontsize))

tiffPlot = ggpubr::ggarrange(ggpubr::ggarrange(p2, p3, nrow = 2, labels = c("A", "B"), font.label = list(size = 9)), ggpubr::ggarrange(p1, labels = "C", font.label = list(size = 9)), ncol = 2, nrow = 1, widths = c(1,3))

ggsave(file = paste(wd, "figures/article_one/Fig8.tiff", sep = ""), plot = tiffPlot, width = 6, height = 3, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig8.jpeg", sep = ""), plot = tiffPlot, width = 6, height = 3, dpi = 300)

rm(cor_genecount_pattern)
rm(spcorr_pattern)
```




Though the relationship seems a common feature among species, some of them are outliers and show a stronger relationship than the rest of species. It would be interesting to look at specific relationships to identify outlying patterns.



## Gene landscapes correlate to recombination landscape

Plot gene landscapes in the same manner as recombination landscapes in (ref:DistancesRelative-pooledChromosomes-patterns).

Number of genes ~ distance to the telomere.



```{r message=FALSE, warning=FALSE, echo=FALSE}
#----------------------------------------------------------------------------#
# Chromosomes pooled per species ----
#----------------------------------------------------------------------------#
df_pooled = read.table(paste(wd, "output/gene_count/DistancesRelativeScaled_bins.txt", sep =""), header = TRUE)
# Quantiles of relative distances are pooled together
df_pooled$species = gsub("_[A-Za-z0-9]*$", "", df_pooled$set)
df_pooled$species = gsub("_MaizeGDBConsensus", "", df_pooled$species)
df_pooled$species = gsub("_", " ", df_pooled$species)

df_pooled = aggregate(df_pooled$gene_count~df_pooled$dist2telomere+df_pooled$species, FUN=mean)
colnames(df_pooled) = c("dist2telomere", "species", "gene_count")

# trim species
df_pooled = df_pooled[-which(df_pooled$species %in% gsub("_", " ", trimspecies)),]
```



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 9, fig.align="center", fig.cap = "(ref:DistancesRelative-pooledChromosomes-GeneCount)"}
DistancesRelative_pooledChromosomes = ggplot(data = df_pooled, aes(x = dist2telomere, y = gene_count)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  geom_point(aes(colour = species), alpha = 0.4) +
  geom_smooth(formula = y ~ x + I(x^2), method = "lm", se = TRUE, color = "Black") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14),
        legend.position='none')
DistancesRelative_pooledChromosomes
```

(ref:DistancesRelative-pooledChromosomes-GeneCount) Standardized gene count as a function of the relative distance from the telomere along the chromosome (physical distances expressed in 20 bins). Chromosomes were split in halves, distance 0.5 being the center of the chromosome. Then, chromosomes were pooled per species. Each color is a species. Linear quadratic regression estimated is the black line (95% confidence interval in dark grey).



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 12, fig.width = 12, fig.align="center", fig.cap = "(ref:DistancesRelative-pooledChromosomes-LOESS-GeneCount)"}
DistancesRelative_pooledChromosomes = ggplot(data = df_pooled, aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
DistancesRelative_pooledChromosomes
```

(ref:DistancesRelative-pooledChromosomes-LOESS-GeneCount) Standardized gene count as a function of the relative distance from the telomere along the chromosome (physical distances expressed in 20 bins). Chromosomes were split in halves, distance 0.5 being the center of the chromosome. Then, chromosomes were pooled per species. Each color is a species. A loess regression was estimated for each species.


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 12, fig.width = 12, fig.align="center", fig.cap = "(ref:DistancesRelative-pooledChromosomes-genecount)"}
# Make 4 figures to identify species individually
species.names = unique(df_pooled$species)

DistancesRelative_pooledChromosomes_1 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[1:12]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
# DistancesRelative_pooledChromosomes_1

DistancesRelative_pooledChromosomes_2 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[13:24]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
# DistancesRelative_pooledChromosomes_2


DistancesRelative_pooledChromosomes_3 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[25:36]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
# DistancesRelative_pooledChromosomes_3


DistancesRelative_pooledChromosomes_4 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[37:48]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  stat_smooth(aes(colour = species), se = FALSE) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')
# DistancesRelative_pooledChromosomes_4

ggarrange(DistancesRelative_pooledChromosomes_1,
          DistancesRelative_pooledChromosomes_2,
          DistancesRelative_pooledChromosomes_3,
          DistancesRelative_pooledChromosomes_4, nrow = 2, ncol = 2)
```

(ref:DistancesRelative-pooledChromosomes-genecount) (ref:DistancesRelative-pooledChromosomes-genecount)


#### Figure S7

```{r include=FALSE}
fontsize =12
linesize = 1

# Make 4 figures to identify species individually
species.names = unique(df_pooled$species)

p1 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[1:10]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized gene count") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')

p2 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[11:20]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized gene count") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')


p3 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[21:30]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized gene count") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')

p4 = ggplot(data = df_pooled[which(df_pooled$species %in% species.names[31:40]),], aes(x = dist2telomere, y = gene_count)) +
  # geom_line(aes(group = species, colour = species)) +
  xlab("Relative distance to telomere") + ylab("Standardized gene count") +
  stat_smooth(aes(colour = species), se = FALSE, size = linesize) +
  # stat_function(fun = quadrafun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = dist2telomere, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  geom_point(aes(colour = species), alpha = 0.4) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(1,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='bottom')


p =ggpubr::ggarrange(p1, p2, p3, p4, ncol = 2, nrow = 2, labels = "AUTO") +
  theme(plot.margin = margin(1,1,1,1,"cm"))


ggsave(file = paste(wd, "figures/article_one/FigS7.tiff", sep = ""), plot = p, width = 14, height = 14, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS7.jpeg", sep = ""), plot = p, width = 14, height = 14, dpi = 300)
```



Classify gene patterns as we did for crossover patterns.




```{r echo = FALSE}
telomere_pattern$gene_pattern = NA

pattern_telomere = c("Arachis duranensis", "Arachis hypogaea", "Brachypodium distachyon", "Camelina sativa", "Cucumis melo", "Glycine max", "Helianthus annuus", "Eucalyptus grandis", "Gossypium hirsutum", "Gossypium raimondii", "Hordeum vulgare", "Lupinus albus", "Malus domestica", "Mangifera indica", "Manihot esculenta", "Oryza sativa", "Panicum hallii", "Phaseolus vulgaris", "Prunus mume", "Prunus persica", "Oryza nivara", "Sorghum bicolor", "Setaria italica", "Solanum lycopersicum", "Solanum tuberosum", "Theobroma cacao", "Triticum aestivum", "Vigna unguiculata", "Zea mays")
pattern_peak = c("Brassica rapa", "Cucumis sativus","Cucurbita maxima", "Cucurbita pepo", "Dioscorea alata", "Elaeis guineensis", "Vitis vinifera")
pattern_exception = c("Arabidopsis thaliana", "Brassica napus", "Camellia sinensis", "Capsella rubella", "Sesamum indicum")

telomere_pattern$gene_pattern[which(telomere_pattern$species %in% pattern_telomere)] = "telomere"
telomere_pattern$gene_pattern[which(telomere_pattern$species %in% pattern_peak)] = "peak"
telomere_pattern$gene_pattern[which(telomere_pattern$species %in% pattern_exception)] = "exception"

telomere_pattern$gene_pattern = as.factor(telomere_pattern$gene_pattern)

```

```{r echo = TRUE}
table(telomere_pattern$gene_pattern)

table(telomere_pattern$pattern)

# Species that changed of pattern among recombination/genes
telomere_pattern$species[which(telomere_pattern$pattern != telomere_pattern$gene_pattern)]
```


```{r echo = TRUE}
knitr::kable(telomere_pattern, label = c("Species", "Recombination pattern", "Gene density pattern"), caption = "genelandscapes-patterns", align = "c")
```


```{r message=FALSE, warning=FALSE, echo=FALSE}
df_pooled = merge(df_pooled, telomere_pattern)
colorpalette= c("#D55E00", "#0072B2", "black")

# Compute the ribbon for each type of pattern
ribbon = data.frame(pattern = rep(c("telomere","peak"), each = 40), x = rep(df_pooled$dist2telomere[1:40], 2), y = NA, ymin = NA, ymax = NA)
# Estimate ymin and ymax
for (i in 1:nrow(ribbon)) {
    ribbon$y[i] = mean(df_pooled$gene_count[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = FALSE)
    ribbon$ymin[i] = min(df_pooled$gene_count[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = TRUE)
  ribbon$ymax[i] = max(df_pooled$gene_count[which(df_pooled$dist2telomere == ribbon$x[i] & df_pooled$pattern == ribbon$pattern[i])], na.rm = TRUE)
}
ribbon$pattern = factor(ribbon$pattern, levels = c("telomere", "peak", "exception"))
```

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 12, fig.align="center", fig.cap = "(ref:DistancesRelative-pooledChromosomes-patterns-genecount)"}
p1 = ggplot(data = df_pooled[which(df_pooled$pattern == "telomere"),], aes(x = dist2telomere, y = gene_count)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  ylim(-2, 3.5) +
  geom_point(aes(), color = colorpalette[1], alpha = 0.7, size = 3) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
p1 = p1 +
  geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = gene_count, group = species), colour = "black", linetype = "dashed")
# Add smoothed line and ribbon
p1 = p1 +
  geom_line(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, y = y), color = colorpalette[1], size = 3) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[1], fill = colorpalette[1], alpha = 0.2, inherit.aes = FALSE)

p2 = ggplot(data = df_pooled[which(df_pooled$pattern == "peak"),], aes(x = dist2telomere, y = gene_count)) +
  xlab("Relative distance to telomere") + ylab("Gene count") +
  ylim(-2, 3.5) +
  geom_point(aes(), color = colorpalette[2], alpha = 0.7, size = 3) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
p2 = p2 +
  geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = gene_count, group = species), colour = "black", linetype = "dashed")
# Add smoothed line and ribbon
p2 = p2 +
  geom_line(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, y = y), color = colorpalette[2], size = 3) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[2], fill = colorpalette[2], alpha = 0.2, inherit.aes = FALSE)
# p2

ggarrange(p1, p2, ncol = 2, labels = c("A", "B"))
```

(ref:DistancesRelative-pooledChromosomes-patterns-genecount) (ref:DistancesRelative-pooledChromosomes-patterns-genecount) Gene counts are higher in distal regions and lower near the center of the chromosome. Standardized gene count as a function of the relative distance from the telomere along the chromosome (physical distances expressed in 20 bins). Two patterns were identified based on the distribution of recombination rates along the telomere-centromere axis and species were pooled accordingly. Recombination rates decrease immediately from the tip of the chromosome for 35 species (dark grey line and ribbon) or recombination rate is reduced in telomeric regions and the peak of recombination is in a sub-telomeric region for 16 species (light grey line and ribbon). The solid line represents the mean gene count estimated in a bin and upper and lower boundaries of the ribbon represent the maximum and minimum values for a particular pattern. Besides, patterns that were not classified (6 species) were represented by loess regression in grey dashed lines. For estimating gene counts in bins of relative distance, chromosomes were split in halves, a distance of 0.5 being the center of the chromosome. Then, chromosomes were pooled per species.

#### Figure 9

```{r include=FALSE}
fontsize = 10
pointsize = 1
linesize = 0.5

p1 = ggplot(data = df_pooled[which(df_pooled$pattern == "telomere"),], aes(x = dist2telomere, y = gene_count)) +
  xlab("Relative distance to telomere") + ylab("Standardized gene count") +
  ylim(-2, 3.5) +
    geom_text(aes(x = 0.25, y = 2.5, label = "Distal pattern (34 species)"), colour = colorpalette[1]) +
  geom_point(aes(), color = colorpalette[1], alpha = 0.7, size = pointsize) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=fontsize-2, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
# p1 = p1 +
#   geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = gene_count, group = species), colour = "black", linetype = "dashed", size = linesize)
# Add smoothed line and ribbon
p1 = p1 +
  geom_line(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, y = y), color = colorpalette[1], size = 1.2) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "telomere"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[1], fill = colorpalette[1], alpha = 0.2, inherit.aes = FALSE)

p2 = ggplot(data = df_pooled[which(df_pooled$pattern == "peak"),], aes(x = dist2telomere, y = gene_count)) +
  xlab("Relative distance to telomere") + ylab("Standardized gene count") +
  ylim(-2, 3.5) +
  geom_text(aes(x = 0.25, y = 2.5, label = "Sub-distal pattern (16 species)"), colour = colorpalette[2]) +
  geom_point(aes(), color = colorpalette[2], alpha = 0.7, size = pointsize) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=fontsize-2, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# Add exceptions patterns
# p2 = p2 +
#   geom_line(data = df_pooled[which(df_pooled$pattern != "telomere" & df_pooled$pattern != "peak"),], aes(x = dist2telomere, y = gene_count, group = species), colour = "black", linetype = "dashed", size = linesize)
# Add smoothed line and ribbon
p2 = p2 +
  geom_line(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, y = y), color = colorpalette[2], size = 1.2) +
  geom_ribbon(data = ribbon[which(ribbon$pattern == "peak"),], aes(x = x, ymin = ymin, ymax = ymax), color = colorpalette[2], fill = colorpalette[2], alpha = 0.2, inherit.aes = FALSE)
# p2

tiffPlot = ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("A", "B"), font.label = list(size = 9))

ggsave(file = paste(wd, "figures/article_one/Fig9.tiff", sep = ""), plot = tiffPlot, width = 6, height = 2.7, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig9.jpeg", sep = ""), plot = tiffPlot, width = 6, height = 2.7, dpi = 300)
```



# Genetic shuffling

```{r echo = FALSE}
# Import chromosomal genetic shuffling rates for distances in Mb
df_geneticshuffling_physical_chr = read.table(paste(wd, "tables/df_geneticshuffling_physical_chr.txt", sep = ""), header = TRUE, stringsAsFactors = FALSE)
chromosome.stats.shuffling = merge(chromosome.stats, df_geneticshuffling_physical_chr, by = c("set", "chromosome"))
# Import chromosomal genetic shuffling rates for distances in gene distance
df_geneticshuffling_genedist_chr = read.table(paste(wd, "tables/df_geneticshuffling_genedist_chr.txt", sep =""), header = TRUE, stringsAsFactors = FALSE)
# Trim species
df_geneticshuffling_genedist_chr$species = NA
for (i in 1:nrow(df_geneticshuffling_genedist_chr)) {
  df_geneticshuffling_genedist_chr$species[i] = unique(chromosome.stats$species[which(chromosome.stats$set == df_geneticshuffling_genedist_chr$set[i])])
}
df_geneticshuffling_genedist_chr = df_geneticshuffling_genedist_chr[-which(df_geneticshuffling_genedist_chr$species %in% gsub("_", " ", trimspecies)),]
# Trim chromosomes
df_geneticshuffling_genedist_chr = df_geneticshuffling_genedist_chr[-which(paste(gsub(" ", "_", df_geneticshuffling_genedist_chr$species), df_geneticshuffling_genedist_chr$chromosome, sep  = "_") %in% paste(trimchromosomes$species, trimchromosomes$chr, sep  = "_")),]

df_geneticshuffling_genedist_chr = df_geneticshuffling_genedist_chr[,1:3]

colnames(df_geneticshuffling_genedist_chr)[3] = "geneticshuffling_genedist"
chromosome.stats.shuffling = merge(chromosome.stats.shuffling, df_geneticshuffling_genedist_chr, by = c("set", "chromosome"))
```

## Correlations with genetic shuffling rates

```{echo = TRUE}
# Sample size
length(!is.na(chromosome.stats.shuffling$geneticshuffling_genedist))
```

```{r echo = TRUE}
hist(sqrt(chromosome.stats.shuffling$peripherybias_ratio), main = "", xlab = "Periphery-bias ratio (square root)", breaks = 40)

hist(chromosome.stats.shuffling$geneticshuffling, main = "", xlab = "Genetic shuffling", breaks = 40)

hist(chromosome.stats.shuffling$geneticshuffling_genedist, main = "", xlab = "Genetic shuffling", breaks = 40)
```


### Chromosomal level

Hypothesis: Crossovers clustered in distal regions are less efficient than crossovers evenly distributed in the chromosome.

```{r echo = TRUE}
lmer.model = lmer(geneticshuffling ~ (peripherybias_ratio) + (1|species), data = chromosome.stats.shuffling)
summary(lmer.model)

r.squaredGLMM(lmer.model)

# Confidence interval of the coefficients was computed by bootstrap
# Parametric bootstrap
lmer.confint = confint(lmer.model, level = 0.95,
	method = "boot", nsim = 1000, boot.type = "norm")

# Quadratic function and C.I.
lmerfun = function(x, c) {fixef(lmer.model)[[1]] + fixef(lmer.model)[[2]]*x}
lowerlmerfun = function(x, c) {lmer.confint[[3]] + lmer.confint[[4]]*x}
upperlmerfun = function(x, c) {lmer.confint[[7]] + lmer.confint[[8]]*x}
# The C.I. values
df.new = data.frame(peripherybias_ratio = (chromosome.stats.shuffling$peripherybias_ratio))
df.new$lwr.pred = lowerlmerfun((chromosome.stats.shuffling$peripherybias_ratio))
df.new$upr.pred = upperlmerfun((chromosome.stats.shuffling$peripherybias_ratio))
```
```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 8, fig.align="center", fig.cap = "(ref:shuffling-peripherybias)"}
p = ggplot(data = chromosome.stats.shuffling, aes(x = peripherybias_ratio, y= geneticshuffling, color = species)) +
  geom_point() +
  geom_smooth(method = "lm",se = F) +
  # geom_smooth(method = "lm", se = TRUE, color = "Black") +
  # geom_abline(intercept = fixef(mod)[1], slope = fixef(mod)[2], size = 1.2) +
  # scale_x_sqrt() +
  stat_function(fun = lmerfun, colour = "Black", size = 1.2) +
  geom_ribbon(data = df.new, aes(x = peripherybias_ratio, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  xlab("Periphery-bias ratio") + ylab("Genetic shuffling") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
p
```


(ref:shuffling-peripherybias) (ref:shuffling-peripherybias)

#### Figure S9

```{r include=FALSE}
fontsize = 11

p = ggplot(data = chromosome.stats.shuffling, aes(x = peripherybias_ratio, y = geneticshuffling, color = species)) +
  geom_point() +
  geom_smooth(method = "lm",se = F) +
  geom_smooth(method = "lm", se = TRUE, color = "Black") +
  ylab("Genetic shuffling") + xlab("Periphery-bias ratio") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

ggsave(file = paste(wd, "figures/article_one/FigS9.tiff", sep = ""), plot = p, width = 7, height = 5, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS9.jpeg", sep = ""), plot = p, width = 7, height = 5, dpi = 300)
```


As expected intuitively, larger genetic maps have a higher Genetic shuffling.


```{r echo = TRUE}
lmer.model = lmer(geneticshuffling ~ linkage.map.length.correctedHW + (1|species), data = chromosome.stats.shuffling)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 8, fig.align="center", fig.cap = "(ref:shuffling-linkagemaplength)"}
p = ggplot(data = chromosome.stats.shuffling, aes(x = linkage.map.length.correctedHW, y = geneticshuffling, color = species)) +
  geom_point() +
  geom_smooth(method = "lm",se = F) +
  geom_smooth(method = "lm", se = TRUE, color = "Black") +
  # geom_abline(intercept = fixef(mod)[1], slope = fixef(mod)[2], size = 1.2) +
  # scale_x_sqrt() +
  # stat_function(fun = lmerfun, colour = "Black", size = 1.2) +
  # geom_ribbon(data = df.new, aes(x = peripherybias_ratio, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  ylab("Genetic shuffling") + xlab("Linkage map length") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
p
```
(ref:shuffling-linkagemaplength) (ref:shuffling-linkagemaplength)

#### Figure S8

```{r include=FALSE}
fontsize = 11

p = ggplot(data = chromosome.stats.shuffling, aes(x = linkage.map.length.correctedHW, y = geneticshuffling, color = species)) +
  geom_point() +
  geom_smooth(method = "lm",se = F) +
  geom_smooth(method = "lm", se = TRUE, color = "Black") +
  ylab("Genetic shuffling") + xlab("Linkage map length (cM)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

ggsave(file = paste(wd, "figures/article_one/FigS8.tiff", sep = ""), plot = p, width = 7, height = 5, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/FigS8.jpeg", sep = ""), plot = p, width = 7, height = 5, dpi = 300)
```




### Species level

We need information about chromosome relative sizes and all chromosomes to compute the chromosomal component Genetic shuffling for a species.



## Gene distances instead of physical distances in Mb

#### Figure S10

Save gene densities for information in a Supplementary pdf...

```{r include = FALSE}
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats.shuffling), function(x) {
  # import Marey map
  genemap = read.table(paste(wd, "data-cleaned/genome/gene_count/", chromosome.stats.shuffling$set[x], "_chromosome", chromosome.stats.shuffling$chromosome[x], ".txt.gz", sep = ""), header = TRUE)
  xmax = chromosome.stats.shuffling$phys.map.length[x]
  # Make the figure as a ggplot object
  ggplot(data = genemap, aes(x = phys, y = gene_count)) +
    ggtitle(paste(chromosome.stats.shuffling$species[x], "chromosome", chromosome.stats.shuffling$chromosome[x], sep = " ")) +
    xlim(0, max(c(genemap$phys, xmax), na.rm = TRUE)) +
    geom_point(size = 1.2, alpha = 0.4) +
    geom_smooth(method = "loess", se = TRUE, color = "blue") +
    xlab("Genomic position (Mb)") + ylab("Gene count (100kb windows)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')
  })

# Save list of plots
# ggsave(filename = paste(wd, "figures/article_one/FigS10.pdf", sep = ""), 
#    plot = marrangeGrob(p, nrow=1, ncol=1), 
#    width = 15, height = 9
# )
```


```{r include = FALSE}
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats.shuffling), function(x) {
  # import Marey map
  genemap = read.table(paste(wd, "data-cleaned/genome/gene_count/", chromosome.stats.shuffling$set[x], "_chromosome", chromosome.stats.shuffling$chromosome[x], ".txt.gz", sep = ""), header = TRUE)
  xmax = chromosome.stats.shuffling$phys.map.length[x]
  # Make the figure as a ggplot object
  ggplot(data = genemap, aes(x = phys, y = gene_count)) +
    ggtitle(paste(chromosome.stats.shuffling$species[x], "chromosome", chromosome.stats.shuffling$chromosome[x], sep = " ")) +
    xlim(0, max(c(genemap$phys, xmax), na.rm = TRUE)) +
    geom_point(size = 0.7, alpha = 1) +
    geom_smooth(method = "loess", se = TRUE, color = "blue", size = 0.8) +
    xlab("Genomic position (Mb)") + ylab("Gene count (100kb windows)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=8, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=8),
        axis.title.y = element_text(color="black", size=8),
        axis.text=element_text(size=8, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=8, face = "italic"),
        legend.title=element_text(size=8),
        legend.position='right')
  })

# Save list of plots
ggsave(filename = paste(wd, "figures/article_one/FigS10.pdf", sep = ""), 
   plot = marrangeGrob(p, nrow=1, ncol=1, top = NULL), 
   width = 4, height = 2, dpi = 75, useDingbats = TRUE
)
```



#### Figure S11

Save Marey maps with gene distances in a Supplementary pdf...

```{r include = FALSE}
# Save all Marey maps and recombination maps in supplementary
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats.shuffling), function(x) {
  # import Marey map
  genemap = read.table(paste(wd, "data-cleaned/genome/gene_distance/", chromosome.stats.shuffling$set[x], ".txt.gz", sep = ""), header = TRUE)
  genemap = subset(genemap, genemap$map == chromosome.stats.shuffling$chromosome[x])
  # Make the figure as a ggplot object
  ggplot(data = genemap, aes(x = (phys/max(phys, na.rm = TRUE)), y = gen)) +
    ggtitle(paste(chromosome.stats.shuffling$species[x], "chromosome", chromosome.stats.shuffling$chromosome[x], sep = " ")) +
    geom_point() + # Add markers
    geom_point(aes(x = (gene_distance/max(gene_distance, na.rm = TRUE))), color = "Darkgrey") +
    geom_segment(aes(x = 0, y = 0, xend = 1, yend = max(gen, na.rm = TRUE)), linetype = 2) +
        # Add centromere position
    geom_vline(aes(xintercept = chromosome.stats.shuffling$centromere_position_estimated[x]/(max(phys, na.rm = TRUE)/1000000)), size = 1) +
    xlab("Relative Genomic position (Mb) or Gene distance (cumulative number of genes)") + ylab("genetic distance (cM)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')
  })

# Save list of plots
# ggsave(filename = paste(wd, "figures/article_one/FigS11.pdf", sep = ""),
#    plot = marrangeGrob(p, nrow=1, ncol=1), 
#    width = 10, height = 10, dpi = 75, useDingbats = TRUE
# )
```


```{r include = FALSE}
# Save all Marey maps and recombination maps in supplementary
# Create multiple plots using lapply()
p = lapply(1:nrow(chromosome.stats.shuffling), function(x) {
  # import Marey map
  genemap = read.table(paste(wd, "data-cleaned/genome/gene_distance/", chromosome.stats.shuffling$set[x], ".txt.gz", sep = ""), header = TRUE)
  genemap = subset(genemap, genemap$map == chromosome.stats.shuffling$chromosome[x])
  # Make the figure as a ggplot object
  ggplot(data = genemap, aes(x = (phys/max(phys, na.rm = TRUE)), y = gen)) +
    ggtitle(paste(chromosome.stats.shuffling$species[x], "chromosome", chromosome.stats.shuffling$chromosome[x], sep = " ")) +
    geom_point(size = 0.7) + # Add markers
    geom_point(aes(x = (gene_distance/max(gene_distance, na.rm = TRUE))), color = "Darkgrey", size = 0.7) +
    geom_segment(aes(x = 0, y = 0, xend = 1, yend = max(gen, na.rm = TRUE)), linetype = 2, size = 0.7) +
        # Add centromere position
    geom_vline(aes(xintercept = chromosome.stats.shuffling$centromere_position_estimated[x]/(max(phys, na.rm = TRUE)/1000000)), size = 1) +
    xlab("Relative Genomic position (Mb) or\nGene distance (cumulative number of genes)") + ylab("Genetic distance (cM)") +
    theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=8, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=8),
        axis.title.y = element_text(color="black", size=8),
        axis.text=element_text(size=8, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=8, face = "italic"),
        legend.title=element_text(size=8),
        legend.position='right')
  })

# Save list of plots
ggsave(filename = paste(wd, "figures/article_one/FigS11.pdf", sep = ""), 
   plot = marrangeGrob(p, nrow=1, ncol=1, top = NULL), 
   width = 4, height = 4, dpi = 75, useDingbats = TRUE
)
```



Some examples of well chosen recombination landscapes in physical/gene distance.


<!-- ```{r echo = FALSE} -->
<!-- # Produce one figure per Marey map with gene distances instead of physical distances in Mb. -->
<!-- # List of all maps (all maps with a gc_genes file giving the list of genes and their position in a reference genome) -->
<!-- list = system(paste("ls ", wd, "/data-cleaned/genome/gene_distance/", sep = ""), intern = TRUE) -->
<!-- list = list[grep("*.txt.gz", list)] -->
<!-- list = gsub("_gene_positions.txt.gz", "", list) -->
<!-- # list -->
<!-- for (sp in list) { -->
<!--   # cat("================================\n") -->
<!--   # cat("Processing", sp, "...\n") -->
<!--   # Load the map with gene distances and genetic distances (cM) -->
<!--   gene_distance_data = read.table(file = gzfile(paste(wd, "data-cleaned/genome/gene_distance/", sp, sep = "")), header = TRUE, sep = "\t", stringsAsFactors = FALSE) -->
<!--   # Run for each chromosome -->
<!--   list_chr = unique(gene_distance_data$map, na.rm = TRUE) -->
<!--   list_chr = list_chr[which(!is.na(list_chr))] -->
<!--   for (chr in list_chr) { -->
<!--     gene_distance_map = gene_distance_data[gene_distance_data$map == chr,] -->
<!--     # Some maps have gene distances == 0 -->
<!--     if (max(gene_distance_map$gene_distance, na.rm = TRUE) > 0) { -->
<!--       # Save the figure -->
<!--       set = unique(gene_distance_map$set) -->
<!--       set = set[which(!is.na(set))] -->
<!--       # cat("Saving", set, "chromosome", chr, "\n") -->
<!--     png(filename = paste(wd, "output/gene_distances/marey_maps/", set, "_chr", chr, ".png", sep = ""), width = 1600, height = 860) -->
<!--     par(mfrow = c(1,2)) -->
<!--     plot(gene_distance_map$phys/1000000, gene_distance_map$gen, xlab = "Physical distance (Mb)", ylab = "Genetic distance (cM)", main = paste(set, "_chr", chr, sep = "")) -->
<!--     lines(x = c(min(gene_distance_map$phys/1000000, na.rm = TRUE), max(gene_distance_map$phys/1000000, na.rm = TRUE)), y = c(min(gene_distance_map$gen, na.rm = TRUE), max(gene_distance_map$gen, na.rm = TRUE))) -->
<!--     plot(gene_distance_map$gene_distance, gene_distance_map$gen, xlab = "Gene distance\n(cumulative number of genes)", ylab = "Genetic distance (cM)", main = paste(set, "_chr", chr, sep = "")) -->
<!--     lines(x = c(min(gene_distance_map$gene_distance, na.rm = TRUE), max(gene_distance_map$gene_distance, na.rm = TRUE)), y = c(min(gene_distance_map$gen, na.rm = TRUE), max(gene_distance_map$gen, na.rm = TRUE))) -->
<!--     par(mfrow = c(1,1)) -->
<!--     dev.off() -->
<!--     # Interestingly, -->
<!--     png(filename = paste(wd, "output/gene_distances/map_correlations/", set, "_chr", chr, ".png", sep = ""), width = 860, height = 860) -->
<!--     plot(gene_distance_map$phys/1000000, gene_distance_map$gene_distance, xlab = "Physical distance (Mb)", ylab = "Gene distance", main = paste(set, "_chr", chr, sep = "")) -->
<!--     lines(x = c(0, max(gene_distance_map$phys/1000000, na.rm = TRUE)), y = c(0, max(gene_distance_map$gene_distance, na.rm = TRUE))) -->
<!--     dev.off() -->
<!--     } -->
<!--   } -->
<!-- } -->
<!-- ``` -->



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 8, fig.width = 15, fig.align="center", fig.cap = "(ref:marey-genedistances)"}
# Import data for the selected species
# Plot one chromosome per species with a centromere position,
# but add a pale ribbon of all pooled chromosomes for each species (similarity of recombination landscapes within species)
df = data.frame(set = c("Arabidopsis_thaliana_Serin2017",
        "Capsella_rubella_Slotte2013",
        "Eucalyptus_grandis_Bertholome2015",
        "Malus_domestica_DiPierro2016",
        "Oryza_sativa_DeLeon2016",
        "Zea_mays_MaizeGDBConsensus_v4"),
        chromosome = as.character(c(3,1,2,10,10,10)))      

# One Marey map per row
# Superpose Marey in base pairs and gene distances
# Relative x scale
# Relative y scale

# Import Marey maps
i = 1
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_arabidopsis = ggplot(data = map, aes(x = phys, y = gen)) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed") +
  geom_point(size = 2) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = 2, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')


i = 2
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_capsella = ggplot(data = map, aes(x = phys, y = gen)) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed") +
  geom_point(size = 2) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = 2, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')

i = 3
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_eucalyptus = ggplot(data = map, aes(x = phys, y = gen)) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed") +
  geom_point(size = 2) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = 2, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')


i = 4
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_malus = ggplot(data = map, aes(x = phys, y = gen)) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed") +
  geom_point(size = 2) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = 2, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')


i = 5
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_oryza = ggplot(data = map, aes(x = phys, y = gen)) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed") +
  geom_point(size = 2) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = 2, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')

i = 6
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_zea = ggplot(data = map, aes(x = phys, y = gen)) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed") +
  geom_point(size = 2) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = 2, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14, face = "italic"),
        legend.title=element_text(size=14),
        legend.position='right')

ggpubr::ggarrange(landscape_capsella, landscape_arabidopsis,
                  landscape_malus, landscape_eucalyptus,
                  landscape_oryza, landscape_zea, ncol = 3, nrow = 2, labels = c("A", "B", "C", "D", "E", "F"))
```


(ref:marey-genedistances) (ref:marey-genedistances landscape_capsella, landscape_arabidopsis, landscape_malus, landscape_eucalyptus, landscape_oryza, landscape_zea)

#### Figure 10

```{r include=FALSE}
fontsize = 9
linesize = 0.5
pointsize = 0.5

# Import data for the selected species
# Plot one chromosome per species with a centromere position,
# but add a pale ribbon of all pooled chromosomes for each species (similarity of recombination landscapes within species)
df = data.frame(set = c("Arabidopsis_thaliana_Serin2017",
        "Capsella_rubella_Slotte2013",
        "Eucalyptus_grandis_Bertholome2015",
        "Malus_domestica_DiPierro2016",
        "Oryza_sativa_DeLeon2016",
        "Zea_mays_MaizeGDBConsensus_v4"),
        chromosome = as.character(c(3,1,2,10,10,10)),
        chrom_size = c(23.5, 19.6, 59.5, 43.8, 23.2, 151))      
# Add chromosome size

# One Marey map per row
# Superpose Marey in base pairs and gene distances
# Relative x scale
# Relative y scale

# Import Marey maps
i = 1
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_arabidopsis = ggplot(data = map, aes(x = phys, y = gen)) +
  ggtitle(substitute(paste(italic("Arabidopsis thaliana"), " chrom. 3 (23.5 Mb)"))) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed", size = linesize) +
  geom_point(size = pointsize) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = pointsize, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')


i = 2
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_capsella = ggplot(data = map, aes(x = phys, y = gen)) +
    ggtitle(substitute(paste(italic("Capsella rubella"), " chrom. 1 (19.6 Mb)"))) +
geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed", size = linesize) +
  geom_point(size = pointsize) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = pointsize, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')

i = 3
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_eucalyptus = ggplot(data = map, aes(x = phys, y = gen)) +
    ggtitle(substitute(paste(italic("Eucalyptus grandis"), " chrom. 2 (59.5 Mb)"))) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed", size = linesize) +
  geom_point(size = pointsize) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = pointsize, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')


i = 4
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_malus = ggplot(data = map, aes(x = phys, y = gen)) +
    ggtitle(substitute(paste(italic("Malus domestica"), " chrom. 10 (43.8 Mb)"))) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed", size = linesize) +
  geom_point(size = pointsize) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = pointsize, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')


i = 5
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_oryza = ggplot(data = map, aes(x = phys, y = gen)) +
    ggtitle(substitute(paste(italic("Oryza sativa"), " chrom. 10 (23.2 Mb)"))) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed", size = linesize) +
  geom_point(size = pointsize) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = pointsize, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')

i = 6
map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", df$set[i], ".txt.gz", sep = ""), header = TRUE)
# Subset one chromosome
map = map[which(map$map == df$chromosome[i]),]
# Scale relative distances in [0;1]
map$phys = map$phys/max(map$phys, na.rm = TRUE)
map$gen = map$gen/max(map$gen, na.rm = TRUE)
map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
landscape_zea = ggplot(data = map, aes(x = phys, y = gen)) +
    ggtitle(substitute(paste(italic("Zea mays"), " chrom. 10 (151 Mb)"))) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), linetype = "dashed", size = linesize) +
  geom_point(size = pointsize) +
  # geom_smooth(method = "loess", size = 2, se = FALSE, color = "Black") +
  geom_point(aes(x = gene_distance, y= gen), size = pointsize, color = "Darkgrey") +
  # geom_smooth(aes(x = gene_distance, y= gen), method = "loess", size = 2, se = FALSE, color = "Darkgrey") +
  xlab("Relative physical position") + ylab("Relative genetic position") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_blank(),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=fontsize, face = "italic"),
        legend.title=element_text(size=fontsize),
        legend.position='right')


# Import the shuffling model schema as pdf graphics
# p0 = magick::image_read_pdf(paste(wd, "figures/article_one/shuffling_randomness.pdf", sep = ""))
# p0 = as.grob(p0)


tiffPlot = ggpubr::ggarrange(landscape_capsella, landscape_oryza, landscape_arabidopsis,
                  landscape_malus, landscape_eucalyptus,
                  landscape_zea, ncol = 2, nrow = 3, labels = c(""), font.label = list(size = 9), hjust = 0.3) +
  theme(plot.margin = margin(0,0,0,0.1, "cm"))

# tiffPlot = ggpubr::ggarrange(tiffPlot, p0, ncol = 2,
#                              widths = c(2,1), labels = c("A", "B"), font.label = list(size = 9))

# tiffPlot = ggpubr::ggarrange(landscape_capsella, landscape_arabidopsis,
#                   landscape_malus, landscape_eucalyptus,
#                   landscape_oryza, landscape_zea, ncol = 3, nrow = 2, labels = c("A", "B", "C", "D", "E", "F"), font.label = list(size = 9), hjust = 0.3) +
#   theme(plot.margin = margin(0,0,0,0.1, "cm"))

ggsave(file = paste(wd, "figures/article_one/Fig10.tiff", sep = ""), plot = tiffPlot, width = 5.5, height = 5.75, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig10.jpeg", sep = ""), plot = tiffPlot, width = 5.5, height = 5.75, dpi = 300)
```






Genetic shuffling should be (1) higher and (2) more homogeneous when estimated in gene distances rather than physical distances.

```{r echo = TRUE}
# Sample size
nrow(chromosome.stats.shuffling)
length(unique(chromosome.stats.shuffling$species))


summary(chromosome.stats.shuffling$geneticshuffling)
summary(chromosome.stats.shuffling$geneticshuffling_genedist)

# The strength of the difference in genetic shuffling rate between bp and gene distances
mean(chromosome.stats.shuffling$geneticshuffling_genedist, na.rm = TRUE) - mean(chromosome.stats.shuffling$geneticshuffling, na.rm = TRUE)

(mean(chromosome.stats.shuffling$geneticshuffling_genedist, na.rm = TRUE) / mean(chromosome.stats.shuffling$geneticshuffling, na.rm = TRUE)) - 1

# ggplot(data = chromosome.stats.shuffling, aes(x = geneticshuffling)) +
#   geom_histogram(color = "Red", alpha = 0.5, bins = 50) +
#   geom_histogram(aes(x = geneticshuffling_genedist), color = "Blue", alpha = 0.5, bins = 50)

ggplot(data = chromosome.stats.shuffling, aes(x = geneticshuffling)) +
  geom_density(color = "Red", alpha = 0.5) +
  geom_density(aes(x = geneticshuffling_genedist), color = "Blue", alpha = 0.5)

boxplot(chromosome.stats.shuffling$geneticshuffling, chromosome.stats.shuffling$geneticshuffling_genedist, names = c("Physical distances", "Gene distances"))


plot(chromosome.stats.shuffling$geneticshuffling, chromosome.stats.shuffling$geneticshuffling_genedist,
     xlab = "Genetic shuffling", ylab = "Genetic shuffling in gene distances")
abline(0,1)
```


```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 10, fig.align="center", fig.cap = "(ref:dist-shufflingrates)"}
ggplot(data = chromosome.stats.shuffling, aes(x = geneticshuffling)) +
  geom_histogram(color = "Red", alpha = 0.5, bins = 50, size = 1.3) +
  geom_histogram(aes(x = geneticshuffling_genedist), color = "Blue", alpha = 0.5, bins = 50, size = 1.3) +
  xlab("Genetic shuffling") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
```

I made the difference in genetic shuffling rate when changing genomic distances for gene distances (i.e. geneticshuffling_genedist - geneticshuffling). A positive value indicates that considering gene distances increases the genetic shuffling rate.


```{r bootstrap-differencesshufflingrate, echo = TRUE}
# Permutation test of the significance of the difference in genetic shuffling rate
nboot = 1000
boot = numeric(nboot)
set.seed(42)
for (i in 1:nboot) {
  boot[i] = mean(sample((chromosome.stats.shuffling$geneticshuffling_genedist - chromosome.stats.shuffling$geneticshuffling), replace = TRUE), na.rm = TRUE)
}
(mdiff = mean(boot)) # The mean difference in genetic shuffling rate (phys - gene distance)
# i.e. a value under 0 means a higher genetic shuffling rate when considering gene distances
# Is it significant at 0.05
pthreshold = 0.001
(mquant = quantile(boot, c(pthreshold/2, 1-pthreshold/2)))
# The difference is small (though the original shuffling rate is not a large value)
# But the difference is highly significant

```



```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 5, fig.width = 10, fig.align="center", fig.cap = "(ref:differences-shufflingrates)"}

p1 = ggplot(data = chromosome.stats.shuffling, aes(x = geneticshuffling)) +
  geom_histogram(color = "Red", alpha = 0.5, bins = 50) +
  geom_histogram(aes(x = geneticshuffling_genedist), color = "Blue", alpha = 0.5, bins = 50) +
  xlab("Genetic shuffling") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

p2 = ggplot(data = chromosome.stats.shuffling, aes(x = geneticshuffling_genedist - geneticshuffling)) +
  geom_histogram(bins = 50, size = 1.3) +
  geom_vline(aes(xintercept = 0), color = "Red") +
  geom_vline(aes(xintercept = mdiff)) +
  geom_vline(aes(xintercept = mquant[1]), linetype = "dashed") +
  geom_vline(aes(xintercept = mquant[2]), linetype = "dashed") +
  xlab("Difference in shuffling rate") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

# Difference in genetic shuffling rate ~ chromosome length
# One point per species
df = data.frame(species = chromosome.stats.shuffling$species, diff = (chromosome.stats.shuffling$geneticshuffling_genedist - chromosome.stats.shuffling$geneticshuffling), chrsize = chromosome.stats.shuffling$phys.map.length)
df =aggregate(cbind(df$diff, df$chrsize), list(df$species), mean)
colnames(df) = c("species", "diff", "chrsize")

# Regression lines among species
lm.model = lm(diff ~ chrsize, data = df)
summary(lm.model)


p3 = ggplot(data = df, aes(x = chrsize, y = diff)) +
  geom_point() +
  geom_smooth(method = "lm", col = "black") +
  xlab("Chromosome length (Mb)") + ylab("Difference in shuffling rate") +
  scale_x_continuous(trans = "log", breaks = c(10, 50, 100, 500)) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# p2

ggpubr::ggarrange(ggpubr::ggarrange(p1, p2, nrow = 2, labels = c("A", "B")), ggpubr::ggarrange(p3, labels = "C"), ncol= 2, nrow = 1, widths = c(1,2))
```
(ref:dist-shufflingrates) (ref:dist-shufflingrates)



```{r echo = TRUE}
wilcox.test(chromosome.stats.shuffling$geneticshuffling, chromosome.stats.shuffling$geneticshuffling_genedist)
```

Longer chromosomes have a higher difference between genetic shuffling rates in bp/gene distances.



```{r echo = TRUE}
lmer.model = lmer((geneticshuffling_genedist - geneticshuffling) ~ log10(phys.map.length) + (1|species), data = chromosome.stats.shuffling)
summary(lmer.model)

r.squaredGLMM(lmer.model)
```

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 6, fig.width = 11, fig.align="center", fig.cap = "(ref:shuffling-differencesshufflingrates)"}
# Confidence interval of the coefficients was computed by bootstrap
# Parametric bootstrap
set.seed(42)
lmer.confint = confint(lmer.model, level = 0.95,
	method = "boot", nsim = 1000, boot.type = "norm")

# Quadratic function and C.I.
lmerfun = function(x, c) {fixef(lmer.model)[[1]] + fixef(lmer.model)[[2]]*x}
lowerlmerfun = function(x, c) {lmer.confint[[3]] + lmer.confint[[4]]*x}
upperlmerfun = function(x, c) {lmer.confint[[7]] + lmer.confint[[8]]*x}
# The C.I. values
df.new = data.frame(phys.map.length = log10(chromosome.stats.shuffling$phys.map.length))
df.new$lwr.pred = lowerlmerfun(df.new$phys.map.length)
df.new$upr.pred = upperlmerfun(df.new$phys.map.length)

p = ggplot(data = chromosome.stats.shuffling, aes(x = log10(phys.map.length), y= (geneticshuffling_genedist - geneticshuffling), color = species)) +
  scale_x_continuous(breaks = log10(c(5, 20, 100, 200, 500, 1000)), labels = c(5, 20, 100, 200, 500, 1000), limits = log10(c(3, 1000))) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  # geom_smooth(method = "lm", se = TRUE, color = "Black") +
  # geom_abline(intercept = fixef(mod)[1], slope = fixef(mod)[2], size = 1.2) +
  stat_function(fun = lmerfun, colour = "Black", size = 1.2) +
  geom_ribbon(data = df.new, aes(x = phys.map.length, ymin = lwr.pred, ymax = upr.pred), alpha = 0.2, inherit.aes = F, fill = "Black") +
  xlab("Chromosome length") + ylab("Differences in\ngenetic shuffling") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
p
```


(ref:shuffling-differencesshufflingrates) (ref:shuffling-differencesshufflingrates)


## Convergence among patterns?



Is there convergence between patterns, i.e. between telomere patterns, gene patterns, gene distance maps and genetic shuffling?


```{r echo = TRUE}
pattern_convergence = telomere_pattern
# For each species, are gene distance maps more/less/similarly homogeneous than genomic distances?
# For each chromosome, compute the RMSE for gene distances and genomic distances
# RMSE = sqrt(sum((Xobs - Xpred)^2))
chromosome.stats.shuffling$RMSEgenomic = NA
chromosome.stats.shuffling$RMSEgene = NA
for (i in 1:nrow(chromosome.stats.shuffling)) {
  map = read.table(paste(wd, "data-cleaned/genome/gene_distance/", chromosome.stats.shuffling$set[i], ".txt.gz", sep = ""), header = TRUE)
  map = map[which(map$map == chromosome.stats.shuffling$chromosome[i]),]
  # Relative distances
  map$phys = map$phys/max(map$phys, na.rm = TRUE)
  map$gene_distance = map$gene_distance/max(map$gene_distance, na.rm = TRUE)
  # Estimate predicted (i.e. diagonal line)
  # The formula for a strictly linear line is y = 0 + (max(y)/1)*x
  # Because x is a relative distance (O to 1)
  # So slope is...
  slope = max(map$gen, na.rm = TRUE)
  # And predicted...
  map$predictedGenomic = slope*map$phys
  map$predictedGene = slope*map$gene_distance
  # Compute RMSE
  chromosome.stats.shuffling$RMSEgenomic[i] = sqrt(sum((map$gen - map$predictedGenomic)^2))
  chromosome.stats.shuffling$RMSEgene[i] = sqrt(sum((map$gen - map$predictedGene)^2))
  rm(map)
}
chromosome.stats.shuffling$diffRMSE = chromosome.stats.shuffling$RMSEgene - chromosome.stats.shuffling$RMSEgenomic

# for each species, estimate the mean difference between RMSEs
# And classify as less/more homogeneous (>0/<0)
pattern_convergence$diffRMSE = NA
pattern_convergence$genedist_pattern = NA
for (i in 1:nrow(pattern_convergence)) {
  pattern_convergence$diffRMSE[i] = mean(chromosome.stats.shuffling$diffRMSE[which(chromosome.stats.shuffling$species == pattern_convergence$species[i])], na.rm = TRUE)
  
  if (pattern_convergence$diffRMSE[i] == "NaN") {pattern_convergence$diffRMSE[i] = NA} else {
      if (pattern_convergence$diffRMSE[i] > 0) {
    pattern_convergence$genedist_pattern[i] = "less"
  } else {
    if (pattern_convergence$diffRMSE[i] < 0) {
      pattern_convergence$genedist_pattern[i] = "more"
    }
  }
  }

}


# For each species, are differences in genetic shuffling positive (increased) or negative (decreased)?
# geneticshuffling_genedist - geneticshuffling
pattern_convergence$diffgeneticshuffl = NA
for (i in 1:nrow(pattern_convergence)) {
  pattern_convergence$diffgeneticshuffl[i] = mean(chromosome.stats.shuffling$geneticshuffling_genedist[which(chromosome.stats.shuffling$species == pattern_convergence$species[i])] - chromosome.stats.shuffling$geneticshuffling[which(chromosome.stats.shuffling$species == pattern_convergence$species[i])], na.rm = TRUE)
  if (pattern_convergence$diffgeneticshuffl[i] == "NaN") {pattern_convergence$diffgeneticshuffl[i] = NA}
}

# Mean chromosome size
pattern_convergence$meanchrsize = NA
for (i in 1:nrow(pattern_convergence)) {
  pattern_convergence$meanchrsize[i] = mean(chromosome.stats$phys.map.length[which(chromosome.stats$species == pattern_convergence$species[i])], na.rm = TRUE)
}
```


```{r echo = TRUE}
# Number of maps classified as more homogeneous in gene distances:
sum(chromosome.stats.shuffling$diffRMSE < 0, na.rm = TRUE)
# Proportion:
sum(chromosome.stats.shuffling$diffRMSE < 0, na.rm = TRUE)/sum(!is.na(chromosome.stats.shuffling$diffRMSE), na.rm = TRUE)
# Total:
sum(!is.na(chromosome.stats.shuffling$diffRMSE), na.rm = TRUE)
```

```{r echo = TRUE}
# Cross-tables for checking convergence
table(pattern_convergence$gene_pattern, pattern_convergence$pattern)
# How many species more and less?
table(pattern_convergence$genedist_pattern)
# Interaction telomere pattern and gene distance
table(pattern_convergence$gene_pattern, pattern_convergence$genedist_pattern)

# Species that changed of pattern among recombination/genes
pattern_convergence$species[which(pattern_convergence$pattern != pattern_convergence$gene_pattern)]
```

```{r echo = TRUE}
# Cross-tables for checking convergence
table(pattern_convergence$gene_pattern)
table(pattern_convergence$genedist_pattern)
chisq.test(table(pattern_convergence$genedist_pattern, pattern_convergence$gene_pattern))
```



```{r echo = TRUE}
levels(pattern_convergence$pattern) = c("exception", "sub-telomere", "telomere")

knitr::kable(pattern_convergence, label = c("Species", "Recombination pattern", "Gene density pattern", "RMSE difference", "Homogeneization effect of gene distance", "Genetic shuffling difference", "Mean chromosome size"), caption = "genelandscapes-patterns", align = "c")
```

```{r echo = TRUE}
df = pattern_convergence
colnames(df) = c("Species", "Recombination pattern", "Gene density pattern", "RMSE difference", "Homogeneization effect of gene distance", "Genetic shuffling difference", "Mean chromosome size")
write.xlsx(x = df, file = paste(wd, "tables/article_one_supp/tables_supplementary.xls", sep = ""), sheetName = "S11_ConvergencePatterns", row.names = FALSE, append = TRUE)
rm(df)
```


```{r echo = TRUE}
ggplot(data = pattern_convergence, aes(x = pattern, y = diffgeneticshuffl)) +
  geom_violin(aes(colour = pattern, fill = pattern)) +
  geom_dotplot(aes(), binaxis= "y",
               stackdir = "center",
               dotsize = 0.5,
               fill = 1) +
  scale_color_manual(values = c("black", colorpalette[2], colorpalette[1])) +
  scale_fill_manual(values = alpha(c("black", colorpalette[2], colorpalette[1]), 0.5)) +
  xlab("Crossover pattern") +
  ylab("Difference in genetic shuffling") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

# plot(diffgeneticshuffl ~ log(meanchrsize), data = pattern_convergence)

```




```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height = 5, fig.width = 10, fig.align="center", fig.cap = "(ref:differences-shufflingrates)"}
chromosome.stats.shuffling_pattern = merge(chromosome.stats.shuffling,
                                           pattern_convergence,
                                           by = "species")

p1 = ggplot(data = chromosome.stats.shuffling_pattern, aes(x = geneticshuffling_genedist - geneticshuffling, fill = pattern)) +
  geom_histogram(bins = 50, size = 1.3) +
  scale_fill_manual(values = c("black", colorpalette[2], colorpalette[1])) +
  geom_vline(aes(xintercept = 0), color = "Red") +
  geom_vline(aes(xintercept = mdiff)) +
  geom_vline(aes(xintercept = mquant[1]), linetype = "dashed") +
  geom_vline(aes(xintercept = mquant[2]), linetype = "dashed") +
  xlab("Difference in shuffling rate") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

p2 = ggplot(data = pattern_convergence, aes(x = pattern, y = diffgeneticshuffl)) +
  geom_violin(aes(colour = pattern, fill = pattern)) +
  geom_dotplot(aes(), binaxis= "y",
               stackdir = "center",
               dotsize = 0.5,
               fill = 1) +
  scale_color_manual(values = c("black", colorpalette[2], colorpalette[1])) +
  scale_fill_manual(values = alpha(c("black", colorpalette[2], colorpalette[1]), 0.5)) +
  xlab("Crossover pattern") +
  ylab("Difference in\nshuffling rate") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=10, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

# Difference in genetic shuffling rate ~ chromosome length
# One point per species
df = data.frame(species = chromosome.stats.shuffling$species, diff = (chromosome.stats.shuffling$geneticshuffling_genedist - chromosome.stats.shuffling$geneticshuffling), chrsize = chromosome.stats.shuffling$phys.map.length)
df =aggregate(cbind(df$diff, df$chrsize), list(df$species), mean)
colnames(df) = c("species", "diff", "chrsize")
df = merge(df, telomere_pattern, by = "species")

# Regression lines among species
lm.model = lm(diff ~ chrsize, data = df)
summary(lm.model)


p3 = ggplot(data = df, aes(x = chrsize, y = diff)) +
  geom_smooth(method = "lm", col = "black") +
  geom_point(aes(color = pattern)) +
  scale_color_manual(values = c("black", colorpalette[2], colorpalette[1])) +
  geom_hline(aes(yintercept = 0), linetype = 2) +
  xlab("Chromosome size (Mb)") + ylab("Difference in shuffling rate") +
  scale_x_continuous(trans = "log", breaks = c(10, 50, 100, 500)) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# p2

ggpubr::ggarrange(ggpubr::ggarrange(p1, p2, nrow = 2, labels = c("A", "B")), ggpubr::ggarrange(p3, labels = "C"), ncol= 2, nrow = 1, widths = c(1,2))

rm(chromosome.stats.shuffling_pattern)
```

(ref:dist-shufflingrates) (ref:dist-shufflingrates)

#### Figure 11

```{r include=FALSE}
fontsize = 10
linesize = 0.5
pointsize = 0.5

chromosome.stats.shuffling_pattern = merge(chromosome.stats.shuffling,
                                           pattern_convergence,
                                           by = "species")
chromosome.stats.shuffling_pattern$pattern = factor(chromosome.stats.shuffling_pattern$pattern, labels = c("exception", "sub-distal", "distal"))

p1 = ggplot(data = chromosome.stats.shuffling_pattern, aes(x = geneticshuffling_genedist - geneticshuffling, fill = pattern)) +
  geom_histogram(bins = 50, size = 1.3) +
  scale_fill_manual(values = c("black", "dodgerblue3", colorpalette[1])) +
  geom_vline(aes(xintercept = 0), color = "Red") +
  geom_vline(aes(xintercept = mdiff)) +
  geom_vline(aes(xintercept = mquant[1]), linetype = "dashed") +
  geom_vline(aes(xintercept = mquant[2]), linetype = "dashed") +
  xlab("Difference in genetic shuffling") + ylab("Count") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=fontsize-2, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

df = pattern_convergence
df$pattern = factor(df$pattern, labels = c("exception", "sub-distal", "distal"))
p2 = ggplot(data = df, aes(x = pattern, y = diffgeneticshuffl)) +
  geom_violin(aes(colour = pattern, fill = pattern)) +
  geom_dotplot(aes(), binaxis= "y",
               stackdir = "center",
               dotsize = 0.5,
               fill = 1) +
  scale_color_manual(values = c("black", "dodgerblue3", colorpalette[1])) +
  scale_fill_manual(values = alpha(c("black", "dodgerblue3", colorpalette[1]), 0.5)) +
  xlab("Crossover pattern") +
  ylab("Difference in\ngenetic shuffling") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize-2, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')

# Difference in genetic shuffling rate ~ chromosome length
# One point per species
df = data.frame(species = chromosome.stats.shuffling$species, diff = (chromosome.stats.shuffling$geneticshuffling_genedist - chromosome.stats.shuffling$geneticshuffling), chrsize = chromosome.stats.shuffling$phys.map.length)
df =aggregate(cbind(df$diff, df$chrsize), list(df$species), mean)
colnames(df) = c("species", "diff", "chrsize")
df = merge(df, telomere_pattern, by = "species")

# Regression lines among species
lm.model = lm(diff ~ chrsize, data = df)
summary(lm.model)
labels = df$species
labels[which(!(labels %in% c("Capsella rubella", "Arabidopsis thaliana", "Nelumbo nucifera", "Zea mays", "Malus domestica", "Eucalyptus grandis", "Camellia sinensis", "Aegilops speltoides", "Triticum dicoccoides", "Cucumis sativus", "Sorghum bicolor", "Manihot esculenta", "Dioscorea alata", "Mangifera indica")))] = ""
df$labels = labels

p3 = ggplot(data = df, aes(x = chrsize, y = diff)) +
  geom_smooth(method = "lm", col = "black") +
  geom_point(aes(color = pattern)) +
  scale_color_manual(values = c("black", "dodgerblue3", colorpalette[1])) +
  geom_hline(aes(yintercept = 0), linetype = 2) +
  xlab("Chromosome size (Mb)") + ylab("Difference in genetic shuffling") +
  scale_x_continuous(trans = "log", breaks = c(10, 50, 100, 500)) +
  ggrepel::geom_text_repel(aes(label = labels, color = pattern), max.overlaps = 20, size = 3, min.segment.length = 0.05) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=fontsize, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=fontsize),
        axis.title.y = element_text(color="black", size=fontsize),
        axis.text=element_text(size=fontsize, colour="black"),
        legend.key = element_rect(fill = "white", size = 1),
        legend.key.height = unit(1,"line"),
        legend.key.width = unit(2,"line"),
        legend.text=element_text(size=7, face = "italic"),
        legend.title=element_blank(),
        legend.position='none')
# p2

tiffPlot = ggpubr::ggarrange(ggpubr::ggarrange(p1, p2, nrow = 2, labels = c("A", "B"), font.label = list(size = 9)), ggpubr::ggarrange(p3, labels = "C", font.label = list(size = 9)), ncol= 2, nrow = 1, widths = c(1,2))

rm(chromosome.stats.shuffling_pattern)

ggsave(file = paste(wd, "figures/article_one/Fig11.tiff", sep = ""), plot = tiffPlot, width = 7, height = 4, dpi = 300, compression = "lzw")
ggsave(file = paste(wd, "figures/article_one/Fig11.jpeg", sep = ""), plot = tiffPlot, width = 7, height = 4, dpi = 300)
```



# Packages & Session Info

```{r echo = TRUE, message = FALSE, warning = FALSE, include = TRUE}
sessionInfo()

# Citations for libraries
lapply(packages, function(x) citation(x))
```

# References



